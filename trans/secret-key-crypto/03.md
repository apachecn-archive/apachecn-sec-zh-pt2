# 3个初步概念

本章 涵盖

*   比特和字节
*   函数和布尔运算符
*   素数和模运算

在我们进入正题之前，让我们先来看一些初步的概念。我很快地浏览了这些话题，因为现在学校里，甚至是低年级都在教授这些观点。根据需要，本书后面会给出更多的基本思想。

## 3.1位和字节

数据 以*位*的形式存储在计算机中，是*二进制数字*的简写。一个位只是一个数值，它的值可以是0或1。一个比特可以用几种方式存储在计算机中。开关可以打开或关闭。磁铁的北极可以朝上也可以朝下。光可以顺时针或逆时针偏振。电脉冲可以有小振幅，也可以有大振幅。

这些二进制数字可以用来组成二进制数。以下是三位二进制数及其十进制等效值。这些3位数字被称为*八进制*数字 ，意思是它们是以8为基数的数字:

![3-unnumb-1](Images/3-unnumb-1.png)

位在计算机逻辑中也用来表示*逻辑值* 或*真值* 。0代表逻辑值*假*，1代表逻辑值*真*。

一个字符，比如一个字母或者一个数字，可以用一个8位二进制数来表示，这个8位二进制数叫做一个*字节*。术语*字节*是由IBM 的沃纳布赫霍尔茨在1954年创造的。由于每个位有2个可能的值，所以8位可以表示2个 <sup class="fm-superscript">8个</sup>不同的字符:也就是2的8次方，也就是256。这对于26个小写字母、26个大写字母、10个十进制数字、33个标点符号如=和$加上一些控制字符如制表符和换行符就足够了。

有几种方案允许表示额外的字符，例如西里尔ж语、阿拉伯语 س语，甚至中文是，每个语标最多使用4个字节。这些都与我们无关。密码可以处理字符串，而不考虑它们的含义。被加密的字节可能是代表一些中文语标的4个字节中的第三个字节，这是无关紧要的。

为了我们的目的，一个字节有3个身份:(1)它是一个由8个逻辑真/假值组成的字符串；(2)它是8位二进制数，因此是0到255之间的整数，包括0和255，以及(3)它是某些字符的表示，例如字母、数字、标点符号，或者是 语标的一部分。

## 3.2函数和运算符

数学 函数现在在学校的小学年级都有教，所以我确定我不需要解释这个概念，但是建立一些符号和术语是有帮助的。函数接受一个或多个值，并产生另一个值作为结果。取的值称为函数的*输入* 或*参数* ，返回的值称为*输出* 或*结果* 。我们说你*将函数*应用于参数以产生结果。

一个函数可以用一个符号来表示，比如+,也可以用一个字母来表示。当一个符号被使用时，它被称为一个*运算符*，所以+和×是运算符，自变量被称为*操作数*。当函数有一个参数时，符号可以放在参数的前面，如-5或 √ 9，或者放在参数的后面，如5 ！(5阶乘，即1×2×3×4×5 = 120)。如果有两个参数，则符号放在它们之间，如3+4或6×7。当符号是字母时，参数被括在括号中，如f(x)。函数用f表示，参数用x表示。如果有多个参数，则用逗号分隔，如f(a，b，c)。一些关于计算机语言的书区分了变量和参数，但这在这里并不重要。

## 3.3布尔运算符

只是 作为加、减、乘以及类似的函数，对数字进行运算，还有几个函数在表示真值时对比特进行运算。为了纪念英国数学家乔治·布尔，这些函数被称为*逻辑运算符* ，或者*布尔运算符*。

如果A和B为真值，那么逻辑函数**非** 、**与** 、**或** 与**异或** 定义如下:

**非** A为假则A为真，A为真则A为假。

A **和** B如果A和B都为真，则为真，否则为假。

如果A或B或两者都为真，则A **或** B为真，否则为假。

如果A或B中恰好有一个为真，则A **xor** B为真，否则为假。

换句话说，如果A为真，B为假，或者B为真，A为假，A **xor** B为真。**异或**被称为*异或*运算符 。它通常用符号⊕t11】来表示，一个里面带+的圆。****或**运算符通常用符号 ∧ 和 ∨ 表示。很容易记住哪个是哪个，因为代表**和**的符号 ∧ 看起来像没有横杠的大写字母A。**

 **以下是表格形式的四个布尔函数的值:

![3-unnumb-2](Images/3-unnumb-2.png)

通过对相应的比特对进行运算，这四个运算符可以从单个比特扩展为比特串。如果A是0011，表示逻辑值假、假、真、真的四位串，并且如果B是0101，表示逻辑值假、真、假、真，则应用四个布尔运算符给出

![3-unnumb-3](Images/3-unnumb-3.png)

异或运算符广泛用于密码学中。例如，一次性密码本(见第14章)的一个简单实现是对消息的字节和密钥流的字节进行异或运算，如下所示:

![3-unnumb-4](Images/3-unnumb-4.png)

## 3.4基数

在 普通算术中，数字用十进制记数法表示。这种符号是由印度人和阿拉伯人在5世纪和7世纪之间的某个时候发明的。因此十进制数字也被称为*阿拉伯数字* 。这个系统是由比萨的莱昂纳多(莱昂纳多 比萨诺)引入欧洲的，在他那个时代被称为斐波那契。

历史花絮

在列奥纳多的时代，大约是1175-1250年，滑块拼图风靡一时。(有些人认为这个谜题与1874年诺伊斯·查普曼发明的十五个谜题相同。现金奖励的公开竞赛很常见。莱昂纳多是解决这个难题的奇才。他每次都赢。他的竞争对手给了他一个戏谑的名字“斐波那契”，意思是“笨蛋”，列奥纳多欣然接受了这个名字。斐波那契在整个意大利都很出名。当斐波那契在1202年写下他的 *Liber Abaci* (计算之书)时，他想让人们知道它的作者是著名的斐波那契。这么直接说是自吹自擂，有失尊严，所以他在扉页上写了 *Filius Bonacci* ，意思可能是“幸运之子”或“Bonacci之子”。

后来的作者没有领会这个意图，并且拒绝了伟大的莱昂纳多·皮萨诺应该被称为“笨蛋”的想法他们推测达芬奇的姓可能是博纳奇。出于同样的原因，为了提醒他的读者，他是著名的斐波那契，在他的私人作品中，莱昂纳多有时狡猾地称自己为莱昂纳多·博纳契(幸运的莱昂纳多)。

随着时间的推移，人们忘记了菲波纳奇这个谜题天才的名字和名声，直到1836年，藏书家、臭名昭著的偷书贼古列尔莫·利布里(Guglielmo Libri)把这些碎片拼凑起来，发现了*菲利斯* + *波纳奇* = *菲波纳奇*。术语*斐波那契数列* 和*斐波那契数列* 大约是由法国数学家爱德华·卢卡斯在1870年创造的。

好了，回去工作吧。为了解释十进制数，我们使用*指数符号* 。指数意味着一个数要乘以它自身的特定次数。比如5 <sup class="fm-superscript">3</sup> 就是5乘以自身3倍，即5×5×5，也就是125。在指数表达式B <sup class="fm-superscript">E</sup> 中，读作“B的E次方”，或简称为“B的E次方”，B称为*底数*，E称为*指数* 。如果N是任意数，那么N <sup class="fm-superscript">1</sup> 就是N本身。按照惯例，对于除0之外的任何数N，N <sup class="fm-superscript">0</sup> 都是1。术语0 <sup class="fm-superscript">0</sup> 没有定义的值，因为评估0 <sup class="fm-superscript">0</sup> 的不同方式会导致不同的结果。

当我们写一个十进制数，或以10为基数的数，如3456，它的意思是3×1000+4×100+5×10+6×1。使用指数表示法，这与3×10<sup class="fm-superscript">3</sup>+4×10<sup class="fm-superscript">2</sup>+5×10<sup class="fm-superscript">1</sup>+6×10<sup class="fm-superscript">0</sup>相同。从右边开始，低阶数字(在本例中为6)乘以1，下一个数字(即5)乘以10，下一个数字乘以10 <sup class="fm-superscript">2</sup> ，然后是10 <sup class="fm-superscript">3</sup> ，依此类推。如果有50位数字，左边的高位数字将乘以10 <sup class="fm-superscript">49</sup> 。

在其他基数上也是如此。比如二进制用的基数是2。二进制数11001求值为1×2<sup class="fm-superscript">4</sup>+1×2<sup class="fm-superscript">3</sup>+0×2<sup class="fm-superscript">2</sup>+0×2<sup class="fm-superscript">1</sup>+1×2<sup class="fm-superscript">0</sup>，或者16+8+0+0+1，也就是25。计算机工作中常用的一个数基数是*十六进制*或基数16。以16为基数的数字是0123456789ABCDEF或0123456789abcdef。为此，我更喜欢使用大写字母ABCDEF，因为它使所有的十六进制数字具有相同的高度，这样更容易阅读。十六进制数9AB将被计算为9×16<sup class="fm-superscript">2</sup>+10×16<sup class="fm-superscript">1</sup>+11×16<sup class="fm-superscript">0</sup>，或者9×256+10×16+11，这是十进制记数法中的2475。

在密码学中，基数的一个用途是将文本转换成数字。将字母表中的26个字母与基数为26的数字联系起来是很自然的，就像这样:

![3-unnumb-5](Images/3-unnumb-5.png)

单词WORK可以表示为一个数字22×26<sup class="fm-superscript">3</sup>+14×26<sup class="fm-superscript">2</sup>+17×26+10，即396，588。这个值可以像任何数字一样被操作，例如通过加、减或乘。

大数可以用指数记数法表示，也叫*科学*记数法 ，像这样:1.23×10 <sup class="fm-superscript">7</sup> 。这是1.23与10个 <sup class="fm-superscript">7</sup> 的乘积，是1000万，所以1.23×10个 <sup class="fm-superscript">7</sup> 是1230万。这和取1.23，将小数点后7位向右移动 是一样的。

## 3.5质数

数字，特别是大于1的整数，被分类为*素数*或*合数*。如果数是两个较小的正整数的乘积，则称之为合数；否则就是质数。前几个合数是4 = 2×2，6 = 2×3，8 = 2×4，9 = 3×3。前几个质数是2，3，5，7和11。数字1既不是质数，也不是合数。

质数的一个重要性质是，任何数都只能用一种方式写成质数的乘积(除了因子的顺序)。比如，由于30 = 2×3×5，所以除了2、3、5之外，没有一个质数能把30整除。这里2、3和5被称为30的*质因数* 。任何整数的质因数集都是唯一的。确定一个整数的质因数称为*因式分解* 或*因式分解* 。

如果两个整数A和B没有共同的质因数，那么称它们为*互质*T3】或*互质* 。比如20和27互质。如果N是整数，那么N和1总是互质的，而N和0只有在N = 1时才互质。N和N+1总是互质的。

利用正整数，当任意一个数A除以另一个数B，称为*除数* ，结果是一个*商* 和一个*余数* 。称之为商Q和余数R，那么Q定义为使QB不超过A的最大整数，余数表示还剩多少，即R = A-QB。注意0 ≤ R < N .比如假设A是40，B是11。11不超过40的最大倍数是33，所以商是3，因为3×11 = 33。余数是7，因为40-33是 7。

## 3.6模运算

对余数的研究叫做*模运算*。哥廷根大学的数学家卡尔·弗里德里希·高斯于1801年引入了模运算。在模算术中，商被忽略，除数被称为*模数* ，余数被称为*余数* 。在前面的例子中，模数是11，余数是7。如果模数为N，两个数X和Y有相同的余，我们说X和Y是*同余模* *N* ，或者等价地说，X和Y在同一个*余类* 模 N，这就写成X≡ Y (mod N)。比如40≡7 (mod 11)，那么40和7在同一个模11的剩余类中。当X-Y是N的倍数时，或者等价地，当X = Y+aN时，对于某个整数a，X和Y对模N是全等的。

剩余类遵循与普通整数相同的算术规则，例如

![3-unnumb-6](Images/3-unnumb-6.png)

我们称-a为a的*加逆* ，记数法a-b可以认为是a+(-b)的简写。

情况为*乘逆* 比较复杂。同余ax≡b (mod N)有3种情况需要考虑:(1)当a和N互质时，(2)当a和N有一个不整除b的公因数d时，(3)当a、b和N都被公因数d整除时。

1.  假设a和N互为质数。然后有一个唯一剩余a '是模N的乘法逆，所以aa'≡1 (mod N)和a'a≡1 (mod N)。如果a '存在，那么同余ax≡b (mod N)很容易解出为x≡a'b (mod N)。在15.3.2节中，我给出了当N很大时计算a '的有效方法。

2.  如果a和N有一个公因数d > 1，那么a没有模N的乘法逆，不可能有a’使得aa’≡1(mod N)。如果b不能被d整除，那么ax≡b (mod N)无解。比如4x≡5 (mod 12)无解。

3.  设d是a和N的最大公约数，记为gcd (a，N)。即d是能把a和N都整除的最大整数，如果a，b，N都可以被d整除，那么你就可以把a，b，N除以d来化简同余，即(a/d)x≡(b/d) (mod N/d)。

让我们来看一个例子。考虑同余式8x≦4(mod 12)。除以4得到简化的同余式2x≡1 (mod 3)。这个同余式的解是x≡2 (mod 3)，这意味着x可以是3n+2形式的任何整数。回到原来的同余式，x是模 12的余数，所以x必须在0到11的范围内，包括0和11。落入该范围的3n+2型的数目是2、5、8和11。这意味着x的值可以是2、5、8或11中的任何一个。所以同余8x≡4 (mod 12)有4个解。

在本书的后面， **mod** 被用作算术运算符。表达式x mod y，其中x为整数，y为正整数，表示x除以y后的余数，因此27 mod 3为0，27 mod 4为3，27 mod 5 为 2。**