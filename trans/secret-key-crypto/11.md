# 11个分组密码

本章涵盖

*   DES和AES 的加密标准
*   基于矩阵乘法的密码
*   加密和解密完全相同的对合密码
*   波纹密码
*   块链接

我们已经看到了几种对分成字符块的文本进行运算的密码。有些只对2或3个字符的小方块进行操作，如Playfair 、两方块 、三方块 和四方块 。有些对更长的块进行操作，但一次只改变2或3个字符，如双歧 、三歧 或FR-actioned Morse。 这些密码只在每个块的一部分上局部作用。明文中一个字符的改变通常最多改变密文的2或3个字符。

这一章讨论更强类型的分组密码。在这些密码中，即使改变明文的一个位元，或是金钥的一个位元，都会改变大约一半的密文位元，以及几乎所有的密文位元组。这表明密码是高度非线性的(见12.3节)。这些密码仅供计算机使用，通常使用专用硬件来加速加密。

这本书的大部分内容都与计算机密码和方法有关。如果你不关心计算机方法，简单地跳过那些部分。

## 11.1替代-置换网络

许多 分组密码采取的是*置换网络* (SPN)的形式。这个想法是由IBM的Horst Feistel 在1971年首次提出的。加密由几轮组成，每轮可能由一个或多个替换步骤和/或一个或多个置换步骤组成。通常有一个控制整体操作的主键。

替换步骤最常见的选择是(1)简单替换 , (2)部分块与部分密钥的异或运算，或(3)在密钥控制下的多字母替换。密钥可以由取自主密钥的比特和/或取自未被替换的块的一部分的比特组成。例如，块中奇数编号的字节可以用作密钥来加密偶数编号的字节，反之亦然。一种稍微复杂一点的替换形式是从密钥中取出一些位，将它们与块中相同数量的位进行异或运算，并将结果用作多字母密钥来替换块的不同部分。

替换字母通常是事先选定的，从不改变。这些被称为 *S盒*T3。它们可能是简单的替换，也可能是多字母替换，所以S盒在计算机上相当于一个表格。它们通常用4到8个关键位来选择表的行，用块的4或8位作为输入，用相同数量的位作为输出。通常一些复杂的数学会被用于替代字母表的构建。特别是，字母表被设计成非线性的，这在第12.3节中有详细说明。

每一轮的排列通常也是预先确定的，不会改变。置换可以在单个比特、4比特组或8比特字节的单元上操作。在大多数分组密码中，没有用于排列的密钥；它们被硬编码在软件中或硬连接到加密芯片中。

最早的现代分组密码是由IBM的霍斯特·费斯特尔设计的路西法。在Feistel选定Lucifer之前，这个名字被改了好几次，因为他想要一个能体现这个设计邪恶本质的名字。Feistel还反复更改了Lucifer的设计，从最初的在128位块上工作的48位密钥改为在128位块上工作的128位密钥。你可以在https://derekbruff.org/blogs/fywscrypto/tag/lucifer[阅读更多关于路西法的信息(2022年5月访问)。](https://derekbruff.org/blogs/fywscrypto/tag/lucifer)

这是一个微型置换网络密码的示意图。这个密码接受一个16位的明文并产生一个16位的密文。它有4个替换回合和3个换位回合。替换和置换是固定的；它们内置于硬件中。使用了4种不同的替换，S <sub class="fm-subscript">1</sub> ，S <sub class="fm-subscript">2</sub> ，S <sub class="fm-subscript">3</sub> 和S <sub class="fm-subscript">4</sub> 。每次替换需要4个输入位加上一个密钥，K <sub class="fm-subscript">11</sub> 到K <sub class="fm-subscript">44</sub> ，通常是4、6或8位，因此如果所有的密钥都是独立的，密码可能有64、96或128个密钥位。每一轮的换位是不同的。

![11-unnumb-1](img/11-unnumb-1.png)

这个迷你网络密码 被评为三级，因为它相当于一个二元组替换，但它可以用6个替换轮从16位扩大到64位，被评为八级，或者用8个替换轮从128位被评为十级。

Lucifer最终版本的设计直接导致了1977年美国国家标准局 (NBS)正式采用的 *数据加密标准* (DES ) 。因此，我们直接跳到 吧。

## 11.2数据加密标准(DES)

DES是IBM 于1976年通过精简当时的路西法版本开发的。那个版本使用128位的密钥，处理128位的信息块。块大小减少到64位，这是合理的，因为这降低了硬件成本。IBM想使用64位密钥，但NSA坚持将密钥进一步减少到56位，理由是多余的8位可以用作校验和。人们普遍认为，实际原因是国家安全局有能力解决56位DES，但没有64位DES。

IBM原本计划把DES做成6轮密码。当NSA告诉IBM它可以破解6轮版本时，IBM直接跳到了16轮，与Feistel在他的最终版本Lucifer 中使用的轮数相同。

DES的一个新特性，在路西法 的任何版本中都没有，就是在第一个替换步骤之前和最后一个替换步骤之后有一个 位换位。这些是8×8列转置 ，其中列的顺序和行的顺序都被改变。对于初始转置，块的64位从左到右写入网格。列以相反的顺序读出，即8，7，6，5，4，3，2，1。按照2，4，6，8，1，3，5，7的顺序读出这些行。最后的换位与此相反。

这些换位没有密码价值。他们没有增加DES的力量。之所以添加它们，是因为NSA告诉IBM 加密在硬件中进行时应该很快，但在软件中模拟时会很慢。这个想法是为了让艾米丽用暴力破解密码更费时间，也就是说，通过尝试软件中所有可能的密钥。IBM认为置换位会使任何软件实现都非常慢。IBM可能设想了一个过程，通过屏蔽一个接一个地提取比特，然后移位到适当的位置。

这被证明是完全错误的。首先，想要破解DES的敌人可以通过代理购买加密芯片。其次，对于一些合法的应用程序，DES需要嵌入到软件中，所以软件必须很快。第三，比特置换可以快速完成，无需提取单个比特或移位。我将在11.2.3节中展示如何操作。

在最初和最后的置换之间，DES有16轮置换。64位块被分成两半32位。在每一轮中，右半边用来加密左半边。右半部分首先从32位扩展到48位，如下所示。这32位被视为8个4位组。通过附加取自相邻组的前一位和后一位，这些组中的每一组从4位扩展到6位。例如，第三组由第9位到第12位组成。通过将位8附加到左边并将位13附加到右边，这个4位组将从4位扩展到6位。换句话说，6位组将是8、9、10、11、12、13位。八个这样的6位组形成一个48位块。

然后，这个48位块与从56位密钥中取出的48位进行异或运算。每一轮使用哪48位由一个*密钥表* 决定，它基本上是在每一轮后将完整的56位密钥移动几个位置。然后将得到的八个6位组送入八个固定的S盒，即替换。每个S盒给出一个4位结果，因此8个4位结果合在一起形成一个32位块。然后，该块与整个64位块的左半部分进行异或运算。

抛开历史不谈

IBM没有为DES设计一个关键的时间表。最初的想法是在16轮中的每一轮之后，将64位密钥循环4位位置。这样就把密钥留在了原来的位置，准备加密下一个块。当NSA让IBM将密钥大小减少到56位时，IBM被迫引入密钥表。四位移位不再有效。当然，IBM称关键时间表为“特性”

查看每个S盒的另一种方法是将它想象成一个4×16的画面。像Belaso或Vigenère tableau一样，每一行都是4位组的替换表。附加到4位组的两个额外的位用于选择使用表的4行中的哪一行。

每个S盒都经过精心设计，使得6个输入位和4个输出位之间的相关性尽可能小。国家安全局已经找到了一种绝密的方法来设计S盒，以给出尽可能最低的相关性。因为DES如此重要，NSA决定与DES的IBM 设计者分享这个秘密。然而，在检查了IBM的设计后，NSA意识到IBM也发现了这种方法，并在其设计中使用了这种方法。

在每一轮之后，除了最后一轮，64位块的左半部分和右半部分被交换。

### 11.2.1双DES

It 从一开始就明白，56位的密钥对于强大的安全性来说太小了。在DES被采用仅4个月后，电子前沿基金会建造了一台价值25万美元的专用计算机，名为Deep Crack ，仅用56小时就破解了一条DES信息。

针对这一明显弱点的第一个解决方案是使用两个不同的密钥用DES对一条消息加密两次。这个想法被否决了，因为理论上可以发起一次中间相遇攻击来破解DES。也就是说，你从明文向前工作，从密文向后工作，在中间相遇。要做到这一点，您需要获取一个明文已知的密文块。你用所有2个 <sup class="fm-superscript">56个</sup>可能的密钥加密明文，然后用所有2个 <sup class="fm-superscript">56个</sup>可能的密钥解密密文。你比较这些结果，无论你在哪里找到匹配，你就有了一对可能的钥匙。

这次攻击只是理论上的。你需要存储2组2个 <sup class="fm-superscript">56个</sup>解，也就是2个 <sup class="fm-superscript">60个</sup>字节，来进行所有的比较。在20世纪70年代，没有一台计算机能达到这样的存储水平。此外，您预计大约有2个 <sup class="fm-superscript">48个</sup>匹配。这些都需要检查。这是一项艰巨的任务。但是IBM和美国国家安全局希望DES能持续20到30年，这种攻击在这段时间内变得可行是有可能的。可能会使用双DES，但它从未被接受为一个 标准。

### 11.2.2三重DES

*三重DES* ，或 *3DES* ，是对DES较小的56位密钥大小的又一次尝试。它包括获取一个64位数据块，用一个DES密钥对其加密，用第二个DES密钥对其解密，然后用第三个DES密钥对其加密。显然，这比普通DES要花3倍的时间。它没有被广泛使用，因为这使得它非常慢。

有一种更快的方法来提高DES的安全性。只需在DES步骤之前用64位密钥对64位块进行异或运算，在DES步骤之后用不同的64位密钥进行异或运算。将有3个独立的密钥，两个64位异或密钥和56位DES密钥，总共184位。这种方法只比一次DES加密稍长一点时间。

即使第二个异或密钥可以通过查看波形来确定，这仍然比单个DES强得多。通过在DES 步骤前后执行键控简单替换，可以消除波形撤销异或的危险。

### *11.2.3快速位换位

DES 以一个位换位开始和结束。最简单的方法是一个接一个地解开这些位，把它们移动到想要的位置，或者把它们放回原位。大约在1975年，我和纽约约克镇IBM 研究所的大卫·史提芬逊独立发明了一种更快的方法。我将使用一个32位块的转置来演示这种技术。假设以比特形式表示的明文是

![11-unnumb-2](img/11-unnumb-2.png)

其中每个拉丁或希腊字母代表一位的值，即可以是0也可以是1。让我们看看如何转置，这样a移动到第三个位置，b移动到第六个位置，c移动到第九个位置，依此类推。

转置可以通过使用4个特殊表格来完成，每个表格有256个条目。每个条目是一个32位的块或计算机字。第一个表显示了32位块的第一个字节中8位的转置位置，如下所示:

![11-unnumb-3](img/11-unnumb-3.png)

第二个表格显示了32位块的第二个字节中8位的位置:

![11-unnumb-4](img/11-unnumb-4.png)

第三表显示了32位块的第三个字节中8位的位置:

![11-unnumb-5](img/11-unnumb-5.png)

第四个表显示了32位块的第四个字节中8位的位置:

![11-unnumb-6](img/11-unnumb-6.png)

这些点是为了让你更容易看到32位的位置。它们在计算机单词中代表零。现在，转置可以通过在这些特殊表中查找4个字节，并将4个结果32位块进行“或”运算来完成，如下所示:

![11-unnumb-7](img/11-unnumb-7.png)

这不需要移位和屏蔽。整个32- 位换位仅使用4个查表和3个OR运算。这种技术的一个用途是翻转8×8位块。这可以使用256个条目的8个表来完成，或者只使用一个表，将位移动到每个字节 内的正确位置，如下所示:

![11-unnumb-8](img/11-unnumb-8.png)

******

### 11.2.4短砌块

DES和其他分组密码的一个问题是如何处理短分组。对于DES，所有块必须正好有8个字符。假设你的信息有803个字符，100个8个字符的块加上3个。你如何处理最后三个字符？

传统的解决方案是用空值填充最后一个块。对于纸笔加密，一些最受欢迎的技术是添加 XXXXX或空值作为最后5个字符。不幸的是，这给了Emily 5个已知明文的字母。手动加密的一些更好的解决方案是使用一个标记，如XX或JQ，然后使剩余的填充字符随机，如XXESV，或者简单地用低频字符的任意组合填充，如ZPGWV。解密依赖于丽娃识别真正信息结束和填充开始的能力。

在计算机中，填充必须解决两个问题。首先，丽娃必须能够判断消息在哪里结束，或者说，有多少字节的填充。第二，桑德拉想给艾米丽尽可能少为人知的明文。一些提议的方案在两个分数上都失败了。例如，一种方案建议在消息末尾填充以下内容之一:

![11-unnumb-9](img/11-unnumb-9.png)

当块大小为32时，这可以给Emily多达31字节的已知明文。在一般文件中，最后一个块可能是以01结尾的完整块，甚至是02 02，这可能会被误认为是填充。

一个更好的解决方案是在明文文件中放置一个长度字段。这不需要是文件中的字节数，这可能需要4字节长度字段，它可以是最后一个块中的填充字节数。对于DES，这是一个从0到7的数，所以只需要3位。长度字段可以在文件中的任何位置。最常见的位置是第一个字节、最后一个字节和最后一个块的第一个字节。填充字节本身可以随机选择。

为了避免给Emily甚至一个字节的已知明文，长度可以用长度指示符的低阶或高阶比特来编码，并且剩余的未使用比特可以是随机的。这使得长度指示器取0到255之间的任何值。

顺便说一句，没有法律规定你必须在文件末尾填充。如果你想在前面填充，在最后一个街区的开始，或者在第13个街区的中间，请便。只要桑德拉和丽娃同意，他们可以做任何他们认为最妨碍艾米丽的事情。一种可能性是分散填充字节。例如，如果文件需要4个填充字节，你可以把它们放在文件的第二、第四、第六和第八块的末尾，只要丽娃能知道添加了多少个填充字节。

*重叠方法* 是填充的替代方法。再次假设块大小B是8，消息有803个字符，您将前800个字符加密为100个8字符的块。然后将字符796到803加密为第101个块。这样，消息的长度不变，但丽娃必须在破译 块 100之前破译块101。

## 11.3矩阵乘法

接下来我们要看的分组密码是*高级加密标准* (AES )。但是，AES使用一种叫做矩阵乘法的数学运算，这一点本书还没有涉及。我在介绍中承诺，我将提出每一个需要的数学概念，因此本着这种精神，我将在这里讨论矩阵乘法。这个概念在后面几章中是需要的。除非你已经很了解矩阵乘法，否则最好不要跳过这个。

一个*矩阵* 就是一个简单的被称为*标量* 元素的矩形数组。一个标量序列形成一个*向量* ，所以一个矩阵的每一行每一列都是一个向量。这些分别被称为*行向量* 和*列向量* 。m行n列的矩阵称为m×n矩阵。如果m = n，这个矩阵叫做*方阵* 。这里有一个3行5列的矩阵M的例子，叫做3 ×5矩阵。它有15个标量元素，这里用字母a到o表示

![11-unnumb-9-equation-11-1](img/11-unnumb-9-equation-11-1.png)

在这个矩阵中，3行向量是[a，b，c，d，e]，[f，g，h，I，j]和[k，l，m，n，o]，5列向量是[a，f，k]，[b，g，l]，[c，h，m]，[d，I，n]和[e，j，o]。矩阵的行从上到下编号，列从左到右编号。在j列I行找到的M的元素记为M <sub class="fm-subscript">ij</sub> ，所以M <sub class="fm-subscript">11</sub> 是a，M <sub class="fm-subscript">15</sub> 是e，M <sub class="fm-subscript">31</sub> 是k

标量的类型包括数字，例如整数、整数模N、有理数、实数、复数以及后面描述的其他类型。矩阵乘法对每种类型的数字都是一样的。

两个矩阵X和Y的乘积，记为XY，是由X的行乘以Y的列形成的，我们来详细看看这是如何工作的。矩阵的行是向量，矩阵的列是向量。具有相同长度的两个向量可以乘以所谓的*内积* ，也称为*点积* ，因为向量乘法有时由 ● 点表示。该操作取一个向量的元素，将它们成对地乘以第二个向量的相应元素，然后取这些乘积的和。

假设第一个向量是[a，b，c，d]，第二个向量是[e，f，g，h]。它们有相同的长度，4个元素，所以它们可以相乘。他们的内积是

![11-unnumb-9-equation-11-2](img/11-unnumb-9-equation-11-2.png)

设X和Y为4×4矩阵，设P为它们的乘积。即P = XY。假设[a，b，c，d]是X的第I行，[e，f，g，h]是y的第j列。它们的乘积记为P <sub class="fm-subscript">ij</sub> 。换句话说，第I行第j列的元素是X的第I行和y的第j列的乘积

![11-unnumb-9-equation-11-3](img/11-unnumb-9-equation-11-3.png)

类似的表达用于其他矩阵尺寸。每当 b = c 时，大小为a×b和c×d的两个矩阵可以相乘。

## 11.4矩阵乘法

没有 ，这个重复的章节标题不是错误。数学中除了数字还有很多其他的对象可以做加法和乘法。一些例子是向量，矩阵，多项式，四元数，以及更一般的，环的元素。你甚至可以有矩阵的向量，多项式的矩阵，等等。在15.6到15.8节中有更多关于环的内容。矩阵乘法可以基于这些类型的元素及其乘法和加法规则。过程是一样的。取X的第I行与Y的第j行的内积，得到乘积矩阵的第I行第j列的元素。

矩阵乘法是不可交换的，意思是当你把一个给定的方阵X乘以左边或右边的第二个方阵A时，你通常会得到不同的结果。AX≦XA。这些被称为X与a的左乘和右乘 的

 *对于AES，我们关注多项式的乘法和加法。高中代数我们都学过多项式的加法和乘法。从事科学和工程职业的人可能还记得这是怎么做到的。多项式也可以整除。这种除法可以留下余数，所以多项式的模数和整数的模数是一样的。(如果您想回顾这一点，请参考第3.6节。)

AES中使用的标量乘法不是整数乘法，而是对另一个多项式取模的多项式乘法。这大概是本书所能达到的深度，本书针对的是一般的 读者。

## 11.5高级加密标准(AES)

*高级加密标准*是2001年取代DES的更新的分组密码。它最初被称为 *Rijndael* ，以其发明者比利时密码学家文森特·里门和琼·代蒙命名。AES最初以128位或256位块与128位、192位或256位密钥的五种组合形式出现。然而，国家标准与技术研究所 (NIST)确定了该标准的128位块大小。轮数取决于密钥大小:128位密钥10轮，192位密钥12轮，256位密钥14轮。

每轮使用一个轮密钥，由根据*密钥表* 从全密钥中选择的128位组成。在第一轮之前，执行初步操作 AddRoundKey，该操作简单地将该块与轮密钥进行异或运算。接下来的9、11或13轮中的每一轮都由4个操作组成，子字节、移位行、混合列和AddRoundKey。最后一轮没有混合列步骤。

128位块被视为一个4×4字节矩阵，称为*列主顺序* ，简单地说就是字节沿列而不是跨行写入矩阵，如下所示:

![11-unnumb-9-equation-11-4](img/11-unnumb-9-equation-11-4.png)

每一轮的第一步是亚字节。这是对每个字节单独执行的固定简单替换。替代被设计成高度非线性的。第12.3.1节详细讨论了线性特性。

下一步是ShiftRows。这是一种转置，其中矩阵的行分别向左循环0、1、2和3个位置，如下所示:

![11-unnumb-9-equation-11-5](img/11-unnumb-9-equation-11-5.png)

每一轮的第三步，混合列，是矩阵乘法。这不是11.3节中描述的普通整数矩阵乘法。矩阵中的元素被视为多项式的系数。标量加法和乘法运算是对另一个多项式取模的多项式运算。这一切都是精心设计的，因此操作可以在硬件中快速执行。上一轮省略了MixColumns。

每一轮的最后一步是 AddRoundKey。这只是块与由密钥表确定的密钥的一部分的按位异或。

我觉得这种排他性——或者说结尾非常可疑。几位电气工程师告诉我，00和11的异或运算产生的波形不同于01和10的异或运算产生的波形，因此窃听者可以分辨出这两位是什么。这潜在地向窃听者揭示了密钥的128位。在进行高安全性加密时，我尽可能避免使用异或。

当我被迫在加密结束时使用异或运算时，例如当我实现一个标准化算法时，我会确保将密文的每一位反转偶数次。我保留了两个随机的位串R1和R2，大小与块相同，它们的异或R3 = R1 ⊕ R2。然后我先与R1异或密文，然后与R2异或，最后与R3异或。这将使位串恢复到其原始值，有望消除指示性波形 。

或者，你可以使用替换，而不是异或，来反转块中的所有位。你这样做两次，所以你用两个替换步骤来代替三个异或。如果你正在使用AES，我强烈推荐增加这个额外的最后的 步骤。

## 11.6固定与键控替代

早期 在这本书里，所有的替换都使用了混合使用关键字或数字键的字母。本章中的密码DES 和AES 使用可嵌入硬件S盒的固定替代。哪个更好？哪个更强？

当你使用固定替换时，你可以使用复杂的数学来设计一个可以抵抗多种攻击的替换。例如，如果一些输出位与一些输入位有很强的相关性，那就让Emily 对密码使用统计攻击，比如我在8.2节中对杰弗逊转轮密码使用的攻击。

不幸的是，固定换人是艾米丽的活靶子。她可以研究几个月或几年的替代，并可能找到设计者遗漏的弱点。精心制作的替换往往具有数学规律性。替代被表示为特定的数学函数。这本身就是一个弱点，因为它给了Emily一个模拟你的密码的捷径。

我的偏好是使用一个由密钥决定的替换，该密钥可以针对每条消息进行更改。键控替换的每个实例可能比固定替换弱，但是Emily 不能利用这样的弱点，因为她没有用于研究的替换表。如果Emily设法获得明文，也许是通过间谍活动，她可能能够恢复替换并了解它的弱点，但那时为时已晚。知道弱点的唯一价值是解密消息并获得明文。如果Emily已经有了明文，那么密钥就不再有价值了。这样的弱点不会帮助她破译下一条消息，因为那条消息会有不同的密钥，因此会有不同的弱点，如果有的话。

任何其他替换的例子，当字母表由相同的方法混合但使用不同的键时，可能没有相同的弱点。它可能具有相同类型的弱点，例如块的一些比特和/或密钥的比特与输出的一些比特之间的相关性，但是这些比特对于每个实例是不同的。

使用固定S盒的一个理由是，它允许加密硬件的同步操作，其中一个消息跟在另一个消息后面，中间没有间隙。使用混合字母可能需要在字母混杂时暂停。使用混合字母表需要设置。如果可以并行混合字母表，则可以消除或至少减少停顿。也就是说，当前消息被加密或解密时，下一个消息的字母表可以被混合。或者，让用户混合字母，并将混合字母作为长键 的一部分。

如果需要同步操作，并且并行混合字母是不可行的，那么回退技术是在DES 或AEST3】步骤之前和之后，对具有与块相同大小的密钥的块进行异或运算。我视情况将这个方法称为 *XDESX* 或 *XAESX* 。这些异或运算速度极快，并在安全性方面提供了显著的提升。总密钥大小为184位，比3DES大16位。我建议将最终输出反转两次，以屏蔽 波形。

## 11.7对合密码

*对合密码是“一个密码是它自己的逆”的一种花哨说法换句话说，加密等同于解密。如果你用一个对合密码加密两次(用同一个密钥)，你会得到原始的明文。这也叫*自反* 或*自反* 。我们已经看到了一些对合密码。用二进制密钥对明文进行异或运算是对合运算(3.3节)。Bazeries型密码(4 . 6 . 1节)中的分段反转换位 是对合的。翻转一个方阵，也就是把字符从左到右写入一个正方形网格，从上到下读出，这就是对合。这里是一个3×3的翻转矩阵的例子:*

 *![11-unnumb-10](img/11-unnumb-10.png)

数学家称这种操作为*转置* 矩阵。由于换位在密码学中有不同的含义，我就把这个*翻转* 称为矩阵。第11.2.3节描述了一种快速翻转矩阵的方法。

如果你在硬件中构建密码，使用对合密码可以降低成本，简化操作。你的密码机不需要有单独的加密和解密模式。

让我们看看如何构造一些类型的对合密码。

### 11.7.1对合替代

在 一个对合替换中，如果一个字母X变成了一个Y，那么Y必然也变成了X，这意味着这些字母必须成对出现。要构造对合替换，首先列出所有的字母或字符。选择任意一个字母，然后选择它的配对。把这些从单子上划掉。然后选择另一个字母及其配对。把那些从单子上划掉。继续这样做，直到大部分字母配对成功。任何剩下的字母都是它们自己的反义词。与SkipMix(第5.2节)一样，可以使用数字键选择连续的字母。

一个对合替换可以方便地用两行来表示。最上面一行的字母得到正下方的替代，最下面一行的字母得到正上方的替代。这是一个使用关键字WORDGAME和TULIP形成的例子。在这个例子中，R会变成L，L会变成R。

![11-unnumb-11](img/11-unnumb-11.png)

换句话说，这个对合替换的关键是这个2行数组。

没有必要每个字母都与不同的字母配对。几个字母可以通过替换保持不变。这些被称为*不变量* 或*固定点* 。

一个对合二元组替换可以用同样的 方法构造。

### 11.7.2退化多字母替换

要构造一个对合的多字母密码，只需把表格的每一行都变成对合的 代换。

### 11.7.3对合转位

对合 如果消息被分解成固定大小的块，那么换位最容易 构造。让我们假设。称固定的块大小为b。如果对于从位置X移动到位置Y的每个字母，位置Y中的字母移动到位置X，则转置是对合的。换句话说，转置将由字母的成对交换组成。

要构造对合换位，先把1到B的数写成一个列表。从列表中选择任意2个数字。它们是第一对互换的位置。从列表中删除这两个数字，并从列表中选择另一对数字。这是第二双。从列表中删除它们。继续这样做，直到列表最多剩下1个数字。如果你选择在你的换位中有一些固定点，只要早点停止配对就行了。另一种创建固定点数的方法是从列表中一次随机选择2个数字。如果这两个数相同，那就成了一个固定点。

表示一般转置密码的一种方式是列出块中的所有位置，并在它们下面显示它们的新位置。举个例子，

![11-unnumb-12](img/11-unnumb-12.png)

这是计算机使用的最佳格式。当一个人进行换位时，可能更方便的做法是将它折叠成半幅，如下所示:

![11-unnumb-13](img/11-unnumb-13.png)

这是同样的换位，但用了一半的空间。任何一种形式都可以用作变调的键。在这两种情况下，第一个位置的字母移动到第13位，而第13个位置的字母移动到第一个位置，第二个位置的字母移动到第七个位置，而第七个位置的字母移动到第二个位置，等等 等等。

### *11.7.4对合分组密码

现在 我们已经知道了如何构造对合替换和转置，我们准备将这些元素组合在一起，构成对合分组密码。

在这一点上，引入更多的符号会有所帮助。设M是任何消息，或者是明文，或者是密文。我们将对该消息应用密码C表示为CM。如果D是另一个密码，那么将D应用于文本CM将被表示为DCM。这种符号看起来有点奇怪，因为DCM意味着先应用C，再应用D，但它工作得很好。你可以把DCM想成D(C(M))的简写。

DC则是先用C再用D加密形成的密码，这种新的密码称为D和C的*合成* ，合成是将两种密码组合起来形成一种新密码的运算。(有些作者称之为密码C和D的*乘积* ，并将其表示为C♀D。)

例如，Bazeries type 4 (第4.6.1节)将替换与换位结合起来。合成有一个对形成对合密码很重要的数学性质:合成是结合的。这意味着如果A，B，C是密码，那么(AB)C = A(BC)。由于这一特性，多个密码的组合可以不用括号写成，像ABC甚至ABCDEFGH。可以在这样的组合中插入括号，而不会改变结果。例如，ABCDEFGH可以写成一个((BC)(DE))F(GH)。

让我代表*身份密码* ，将每一个明文转换成自身的密码。也就是说，对于任何消息M，IM = M。设C是任何密码。用C’表示它的倒数。(C必须有一个反转，否则消息不能被读取。)则CC' = C'C = I .当C = C '时，密码C是对合的。

设T是对合密码，C是任意密码。那么密码CTC’就是对合密码。这是因为

![11-unnumb-13-equation-11-6](img/11-unnumb-13-equation-11-6.png)

同样，如果A和B是任意密码，那么BCTC‘B’和ABCTC‘B’A’是对合密码，以此类推 等等。

### 11.7.5例，聚三次翻转

让我们 来看一个对合分组密码的例子，我称之为*聚三翻转* 。该密码对64位块进行运算，其形式为ABCTC'B'A '，其中A和C是通用多字母密码，B是对64位进行的列转置运算，T是翻转64位方阵。

密码A和C是周期为8的多字母密码。也就是说，有一个单独的字母表用于加密块的每一行。每个密码的表将有8行，按顺序使用。没有用于选择表格行的键。相反，这8个键用于混合8个字母。A和C总共需要16个不同的密钥，每个密钥可能是一个数字序列，用于SkipMix算法(5.2节)。我建议这16个键每个包含3到8个数字，每个数字的范围是0到255。

密码B是一个列转置 把64位的块当作一个4×16的网格，所以有16个！柱子的可能排列。64位从左到右写入网格的各个行，然后从上到下读出各个列。列的顺序由关键字或关键短语或等效的16位数字字符串决定。

聚三翻是 额定 十。 ******

## 11.8可变长度替换

分组密码可以使用固定长度或可变长度的替换来构建。 *VLA* 和 *VLB* 是使用可变长度替换的分组密码的例子。VLA和VLB 分组 密码都使用128位分组，被视为4行，每行32位。想法是在行中使用可变长度替换，然后通过在列中执行4位替换来混合块。每个密码的密钥是用于混合标签集和4位替换的密钥。

VLA 和VLB 使用等长Post标签替换，如10.5.1节所述。因此，4位标签被4位替代物替换，5位标签被5位替代物替换，等等。这样，块中的每一行都保持恒定的32位长度。每次替换后，新标签被移动到它所在行的末尾，该行被左移以保持在4字节的边界上。标签应该具有至少6位的平均长度。

VLA 是更简单的版本。在每一轮中，首先对该行最左边(高位)的位进行4位替换。然后，用shift对每一行执行一次Post标记替换。如此重复32轮。整个加密使用了128个变长替换和32个定长4位替换。这个密码被定为八级。

当平均标签长度为6位时，我建议VLB 应该有4轮，每轮第1行有6个替换步骤，第2行有7个替换步骤，第3行有8个替换步骤，第4行有9个替换步骤。

应在第1、2和3轮后进行垂直替换。为了提高速度，没有必要在每一轮的每一列中进行列替换。一个合理的选择是在每第三列中替换，例如在第1、4、7列中，...在第一轮之后，在第2、5、8栏中，...，32，在第2轮之后，在第3，6，9栏中，...，第三轮后30。

VLB 被评为10级，可能是这一等级中最快的密码。它需要120个变长替换，带移位，32个垂直4位替换，所以比 VLA略快。

## 11.9波纹密码

*波纹*密码 ，也称为*回绕*密码或*端绕*密码，是基于与本章前面的密码完全不同的原理的分组密码。基本思想是，块中的每个8位字符被用作密钥来加密其右边的下一个字符。这反过来用于加密下一个字符，以此类推，沿着块的长度向下波动，并在末尾环绕。也就是说，块中的最后一个字符被用作加密第一个字符的密钥。波纹密码最适合软件实现，因为它们很少提供并行操作的机会。

波纹密码有很多种。它们可以具有从2开始的任何嵌段长度，并且嵌段长度可以周期性地或随机地变化。我建议最小块长度为5个字符，但是您可能更喜欢从8个字符开始。例如，您可以使用链式数字生成器来选择块长度。当生成器生成数字D时，您可以使下一个块的长度为D+5，或者D+8，甚至20-D。

区块可能重叠。例如，您可以使用固定的块长度8，块从位置1、6、11、16开始，...每5个字符。最后一个块可以绕到消息的开始。当消息长度为20时，最后一个块可以由字符16、17、18、19、20、1、2、3组成。

波纹密码是纯粹的替代密码；它们根本不涉及换位。ripple密码最简单的形式是将每个连续字符与下一个字符进行异或运算，因此x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 被x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>T6】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>代替。然后x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n+1</sub> 被x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>t14】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n+1</sub>代替，以此类推，贯穿整个块。

使用前一个字符加密下一个字符有很多种方法。下面是部分列表。这里A、B和C是简单的替换密码，P是一般的多字母密码。 A(x)、B(x)和C(x)分别代表用A、B和C加密的字符x，P(k，x)代表用P加密的字符x，使用密钥k选择tableau中的行。

<colgroup class="calibre15"><col class="calibre16" span="1" width="20%"> <col class="calibre16" span="1" width="30%"> <col class="calibre16" span="1" width="50%"></colgroup> 
| **异或** | 异或 | x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub> 替换为x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n-1</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub>。 |
| **异曲同工** | 替代和异或 | 有三种变型，x <sub class="fm-subscript1">n</sub> 可能会被a(x<sub class="fm-subscript1">n-1</sub>)⊕x<sub class="fm-subscript1">n</sub>，或者x<sub class="fm-subscript1">n-1</sub>⊕b(x<sub class="fm-subscript1">n</sub>)或者a(x<sub class="fm-subscript1">n-1</sub>)⊕b(x<sub class="fm-subscript1">n</sub>)。 |
| **异构体** | 异或和替代 | x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub> 替换为a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n-1</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript1">n</sub>)。 |
| **添加** | 添加 | x <sub class="fm-subscript1">n</sub> 替换为x <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> 。一如既往，加法是模256。 |
| **项** | 乘加，也叫**线性替换** | x <sub class="fm-subscript1">n</sub> 替换为px <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> ，或者x <sub class="fm-subscript1">n-1</sub> +qx <sub class="fm-subscript1">n</sub> ，或者px <sub class="fm-subscript1">n-1</sub> +qx <sub class="fm-subscript1">n</sub> ，其中p可以是任意整数，q可以是任意奇整数。(如果你使用的字母大小不是256，q必须与字母大小互质。) |
| **【sadd】** | 替换和添加 | x <sub class="fm-subscript1">n</sub> 换成A(x <sub class="fm-subscript1">n-1</sub> )+x <sub class="fm-subscript1">n</sub> ，或者x <sub class="fm-subscript1">n-1</sub> +B(x <sub class="fm-subscript1">n</sub> )或者A(x<sub class="fm-subscript1">n-1</sub>)+B(x<sub class="fm-subscript1">n</sub>)。 |
| **添加** | 添加和替换 | x <sub class="fm-subscript1">n</sub> 换成A(x <sub class="fm-subscript1">n-1</sub> +x <sub class="fm-subscript1">n</sub> )。 |
| **聚** | 一般多字母替换 | x <sub class="fm-subscript1">n</sub> 换成P(x <sub class="fm-subscript1">n-1</sub> ，x <sub class="fm-subscript1">n</sub> )。 |

由于 **xor** 或 **sxor** 可能会泄漏关于其操作数的信息，我建议使用**xor**来代替，这样在异或之后就可以进行简单的替换来屏蔽波形，即a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>T9】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>)。

注意**马德**只是**萨德**的一个特例。即px <sub class="fm-subscript">n-1</sub> 只是A(x <sub class="fm-subscript">n-1</sub> )的特定选择。 **madd** 的优势在于它不需要一个初步的设置阶段来混合替换字母表。同理，注意P(A(x <sub class="fm-subscript">n-1</sub> )，B(x <sub class="fm-subscript">n</sub> ))只是简单地置换tableau的行和列，所以它等价于P(x <sub class="fm-subscript">n-1</sub> ，x <sub class="fm-subscript">n</sub> )，只是使用了不同的tableau。

这些ripple方法中最强的是 **poly** ，其中前面的字符x <sub class="fm-subscript">n-1</sub> 被用作选择tableau中用于加密x <sub class="fm-subscript">n</sub> 的行的键。我把这个方法叫做*键波纹* 。这将需要一个256×256字节的表。如果这个值太大，在将x <sub class="fm-subscript">n-1</sub> 用作键之前，可以通过对x <sub class="fm-subscript">n-1</sub> 应用*缩减替换* 来将x<sub class="fm-subscript">n-1</sub>缩减到较小的范围。例如，x可以减少到x模16，或者减少到(13x+5)模32。合适的缩减范围是0到15、0到31和0到63。如果R是归约替换，P是多字母替换，那么x <sub class="fm-subscript">n</sub> 将被Q(R(x <sub class="fm-subscript">n-1</sub> ，x <sub class="fm-subscript">n</sub> )替换，其中Q是多字母密码，具有由P的表格的顶部16、32或64行组成的归约表格。

如果你不能使用多字母密码，也许是因为即使是简化的表格也会占用太多的空间，或者是因为设置时间太长，那么下一个最好的选择就是使用3个简单的替换。用A(B(x <sub class="fm-subscript">n-1</sub> )+C(x <sub class="fm-subscript">n</sub> ))或a(b(x<sub class="fm-subscript">n-1</sub>)⊕c(x<sub class="fm-subscript">n</sub>))代替x <sub class="fm-subscript">n</sub> 。这叫做*时空权衡* 。3个简单的替换可能比单个多字母替换花费的时间稍长，但是它们将所需的空间从65，536字节减少到768字节，减少了98.8%。

波纹密码并不局限于只使用前面的字符来加密当前字符。如果你愿意，你可以返回几个字符，例如用a(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-I</sub>t5】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>代替x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> ，其中I可以是小于块大小的任何值。也可以使用一个以上的先前字符，例如x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>，或者更一般地，x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-j</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-k</sub>+x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>。使用一般的多字母替换法，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 可以被p(x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-4</sub>T25】⊕x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> )或者P(x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-5</sub> ，P(x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-1</sub> ，x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> )或者其他无限的组合代替。

正如我提到的，可以使用任何大小的块。只要每个字符至少被替换一次，替换可以从块中的任何字符开始，也可以在块中的任何字符结束。如果你愿意的话，你可以绕着这个块走几圈，从最后一个字符绕到第一个字符。甚至可以重叠两个以上的块，或者使一个块完全位于另一个块或一组块内。块大小、块内的起始位置、要替换的字符数量以及与前一个和/或后一个块的重叠可以是固定的，可以定期变化，也可以随机产生。

波纹密码还可以更进一步。一条信息可以用几轮波纹密码加密。在每一轮中，信息可以被分成不同大小的块，这样块的边界就很少或从不排列，加密在块的不同点开始和结束。这就产生了马赛克甚至万花筒的效果。

波纹密码的变体太多了，无法一一列举。这些密码的等级从4到10不等。这里有几个例子。简单的 **xor** ripple使用固定大小的块，从块的第一个字节开始到最后一个字节结束进行两轮替换，并且仅使用前一个字节作为替换密钥，被评为4级。一个 **sadd** ripple密码使用不同大小的块，从块中的可变位置开始，进行至少3轮替换，在可变位置结束，并使用前面的字节作为替换密钥，被评为7。一种 **poly** ripple密码 使用不同大小的块，从块中的可变位置开始，进行至少3轮替换，在可变位置结束，并使用前面的字节加上一个另外的字节，该字节随着块的不同而变化，因为替换密钥被评定为10。镶嵌方法比单层 方法强。

## 11.10区块链

分组链是增强任何分组密码的有价值的工具。区块 链接是指使用每个区块来帮助加密下一个区块。实际上，链接是一种连锁密码，对块而不是对单个字符进行操作。从第N块结转到第N+1块的一组字节称为*链向量*T5。由于消息中的第一个块没有前身，大多数链接方案使用一个*初始化向量* (IV )来加密第一个块，就好像它是来自某个假想的前身块的链向量一样。初始化向量可以从加密密钥中导出，或者可以被视为加密的附加密钥。

抛开比特币和其他加密货币使用的区块链是密码学中使用的区块链的一种特殊形式。这是他们得到这个想法的地方。

![11-unnumb-14](img/11-unnumb-14.png)

最常见的链接形式是将链向量与下一个块逐字符组合。组合字符最常用的方法是异或。然而，可以使用第11.8节中描述的任何组合方法。这通常在四种模式 中的一种模式下完成。

<colgroup class="calibre15"><col class="calibre16" span="1" width="30%"> <col class="calibre16" span="1" width="70%"></colgroup> 
| 

**模式**

 | 

**描述**

 |
| **PP** | 在加密块N+1之前，块N的明文与块N+1的明文组合。 |
| **【PC】** | 对第N+1块加密后，第N块的明文与第N+1块的密文合并。 |
| **【CP】** | 在加密块N+1之前，块N的密文与块N+1的明文组合。 |
| **CC**T5】 | 对第N+1块加密后，将第N块的密文与第N+1块的密文合并。 |

为了获得最大的强度，链接操作应该是累积的。首先，来自块N-1的链向量与块N组合。该结果成为新的链向量，其与块N+1组合。链式 **PP** 最强，链式 **PC** 次之。模式 **CP** 和 **CC** 要弱很多，因为艾米莉可以看到链向量。我建议模式 **CP** 和 **CC** 只能与组合功能**xor**、**相加** 和 **poly** 一起使用。

虽然模式 **CC** 和 **CP** 较弱，但使用它们还是有优势的。在模式 **CC** 和 **CP** 中，不需要单独的初始化向量。Sandra可以使用明文消息的最后一个块作为初始化向量。丽娃可以先简单地破译最后一块。事实上，丽娃可以破译任何块，而不需要先破译块。如果密码使用指示器，这可能是有价值的(第14.3节)。丽娃将首先破译指示块。

让我们来看看一些更强的链接块的方法。

### 11.10.1多字母链

异或 是将block N与block N+1结合的一种弱方式。更好的方法是 **xors** ，即首先使用异或，然后对结果字符使用简单的替换。比这好得多的是使用一种通用的多字母密码。使用链向量中的每个字符作为密钥来选择tableau中的行，以加密块N+1中的相应字符。可以使用4种链接模式中的任何一种。模式PP是 最强。

### 11.10.2加密链接

链接的标准模式使用块N的明文或密文作为链接向量，没有修改。对链向量应用某种加密要强得多。这可以是基本的，例如简单的替换或分段反转(第4.6节)。如果每个块的替换或换位不同，那么这种简单的方法可能是有效的。一个键波纹 非常适合这个目的(第11.8节)。用于链向量的加密应该有它自己的独立密钥。如果链向量被更强地加密，模式**CC**T8】和 **CP** 将不再是 弱。

### 滞后链接

链接 不限于前面的块。链接也可以利用更早的块。块N可以与块N-1组合，或者与多个先前的块组合，例如块N-1和块N-j。如果i > j，这需要i 块的初始化向量。

类似地，链向量可以跨越几个先前的块。例如，链向量可以来自块N-2的后一半和块N-1的前一半。

### 11.10.4室内水龙头

一个 使用明文或密文作为链向量的弱点在于，这些都是或者可能会成为艾米莉所知的。一种解决方案是加密链向量，如第11.10.2节所述。第二种解决方案是从块加密的某个中间回合中获取链向量。这叫做*龙头* 。例如，如果分组密码有10轮，您可以使用第5轮的输出作为链向量。在开始加密下一个块之前，将这个链向量与下一个块的明文相结合。这是模式 **IP** 。

这可以更进一步。您可以使用多个tap，它们可以在多个地方与下面的块结合，或者与明文结合，或者与密文结合，或者在各轮加密之间结合。每次点击都会产生一个单独的链向量，因此对于N次点击，您必须有N个初始化向量。任何或所有这些链向量都可以加密。链向量可以使用相同的密钥加密，或者每个链向量可以有自己独立的密钥。波纹密码(第11.8节)非常适合于加密链 向量。

### 密钥链

通常情况下 ，链接是在每个块的文本上完成的。但是，也可以使用键链接。假设您有一个分组密码，其中每个分组使用相同的密钥K。通过对每个块使用不同的密钥，可以大大增强该密码。实现这一点的一种方法是通过链接。你用K作为密钥加密第一个块。(初始化向量对于密钥链是可选的。)然后你就可以用K ● P <sub class="fm-subscript">1</sub> ，K ● C <sub class="fm-subscript">1</sub> 或者K ● I <sub class="fm-subscript">1</sub> 为密钥对第二个块进行加密，其中 ● 代表组合函数中的一个，比如 **xors** 或者**add**逐字节执行。同样，您使用K ● P <sub class="fm-subscript">2</sub> ，K ● C <sub class="fm-subscript">2</sub> 或K ● I <sub class="fm-subscript">2</sub> 作为密钥对第三个块进行加密，依此类推。这给了你三种新的链接模式， **PK** ， **CK** 和 **IK** 。可以同时使用键链接和块链接，比如说 **PK** 和 **IP** 。这是一个极其强大的 组合。

### 11.10.6链接模式总结

总共有12种可能的链接模式。链接向量可以取自三个来源中的任何一个:明文、内部阶段或当前块的密文。链接向量可以与以下四个目标中的任何一个结合:密钥、明文、内部阶段或下一个块的密文。

除了这些选择之外，链向量可以每次取新的，或者它可以与来自前一个块的链向量相结合。链向量可以原样使用，或者可以在与目标组合之前加密。链接可以在连续的块上操作，或者可以是滞后的。许许多多o f选项。

### 11.10.7链接短块

当 消息中的最后一个块很短，并且你使用重叠方法(第11.2.4节)来处理短块时，不清楚如何链接重叠的块。解决方法是从两个街区后开始连锁。如果有N个块，来自块N-2的链向量被用于块N-1和块N的

### 11.10.8链接可变长度块

一个 最后一个问题在我们离开块链接的话题之前，需要涉及到可变块大小。我建议链向量保持固定长度。如果消息块的长度L小于链向量的长度，则将链向量的前L个字节与消息块合并。替换链向量的L个字节，其余的保持不变。例如，如果链向量为 **1234567890** ，块为 **样本** ，则将 **123456** 与 **样本** 合并。如果这产生了 **ZQm"w+** ，那么块变成了 **ZQm"w+** 并且链向量变成了 **ZQm"w+7890** 。

![11-unnumb-15](img/11-unnumb-15.png)

如果链向量比消息块短，则根据需要用其自身的尽可能多的副本扩展该块的链向量。例如，如果链向量为 **123456** ，块为 **约定** ，则将 **1234561234** 与 **约定** 合并。如果这样得出 **qA & Vm！7^oS** 块变成了 **qA & Vm！7^oS** 和链向量变成了和 **qA & Vm！** 。

![11-unnumb-16](img/11-unnumb-16.png)

在两种情况下，链接后块保持相同的长度，链向量保持相同的长度。

## 11.11加强分组密码

一旦你有了一个强大的分组密码，只需很少的额外努力就可以进一步加强。所需要的只是在应用分组密码之前对明文进行轻度加密，在完成分组密码之后对密文进行轻度加密。我称之为*三明治*技巧，额外的步骤称为*预测器*和*后置密码* 步骤。如果你觉得有点顽皮，你可以称之为*鲁宾三明治*。“轻微”是指使用简单的一轮一步密码，如简单替换或密钥变换(第7.6节)。例如，您可以在分组密码之前使用简单的替换,在分组密码之后使用密钥换位，反之亦然。一个更强但更快的选择是将块的前8个字节视为两个32位整数，并将每个整数乘以范围为3到2 <sup class="fm-superscript">32</sup> -1模2 <sup class="fm-superscript">32</sup> 的奇数乘数。

由于分组密码已经很强大，这些额外步骤的主要目的是增加总密钥大小，以抵御暴力攻击和中间相遇攻击。当precipher 和postcipher步骤具有独立于块密码密钥的长密钥时，这种方法效果最好。例如，如果precipher或postcipher是简单替换，它可能有一个长SkipMix密钥。

作为一个实际的例子，DES 使用了一个小的56位密钥。如果添加简单的替换precipher和postcipher步骤，每个步骤都有一个独立的64位混合密钥，那么总密钥大小将达到184位。这比3DES更强大，速度快了近3倍。

然而， DES 的设计没有任何设置阶段。precipher可以很容易地完成没有设置。简单地与明文异或64位的precipher密钥。这将总密钥大小从56位增加到120位。仅此一点，就比2DES更强，更能抵抗中间人攻击。后置密码步骤有点棘手。出于前面讨论过的原因，我们希望避免在最后一步使用exclusive-OR，并且我们也不希望设置。这可以通过使用固定的多字母密码来实现。也就是说，表格是预先选择的，并内置到设备或软件中。

一种可能性是使用4比特组的16×16表格。64位块被视为16个4位组。每个4位组使用64位后置密码密钥的4位进行加密。因此，总密钥大小还是184位。这也比3DES 强，而且快了将近3倍。

这种方法奏效的原因是DES 本身足够强大，因此唯一可行的攻击是暴力攻击。给密钥增加额外的128个T2位使得暴力破解T4变得不可行。**