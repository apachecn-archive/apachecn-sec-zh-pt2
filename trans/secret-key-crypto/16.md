# 16三关协议

本章涵盖

*   基于幂运算的三重传递协议
*   基于矩阵乘法的三重传递协议
*   基于双边矩阵乘法的三重传递协议

第2.2节 和第2.3节描述了现代密码学如何分为3个分支，秘密密钥、公开密钥和个人密钥。到目前为止，这本书只描述了密钥加密的方法。公钥密码学在很多书中都有描述，这里就不赘述了。本章将讨论个人密钥加密，这是不太为人所知的第三个加密分支。个人密钥加密有时被称为*无密钥*加密，因为双方不需要传输或共享任何密钥。

个人密钥加密的基本概念是两个通信者桑德拉和丽娃都有她自己的个人密钥。这个密钥从不与任何其他人传输或共享，甚至彼此之间也不共享，因此Emily不可能通过窃听、截取广播或任何其他形式的窃听得知任何个人密钥。个人密钥加密的最大优点是你不需要预先设置任何东西。交换密钥不需要任何秘密、安全的通道。这些信息可以在公共频道上交换。不需要关键服务器或其他基础设施。

个人密钥加密是通过*三次通过协议* 来完成的，该协议是由以色列魏茨曼研究所的阿迪·萨莫尔在大约1975年发明的。为了说明这个方法，我设计了一个小故事:

从前有一个国王，他爱上了邻国的王后。为了向王后求爱，国王想送她一颗珍贵的宝石。国王有一个密封的保险箱和一把防盗锁。但是他怎么能把钥匙寄出去呢？如果信差既有钥匙又有保险箱，他就可以打开保险箱偷走宝石。国王可以派第二个信使去送钥匙，但是他担心这两个信使会在路上相遇，一起偷走宝石。女王提出了一个巧妙的解决方案。

国王会把他的锁放在保险箱上，然后把它送给王后。然后，她会添加自己的锁，并将保险箱连同两把锁一起寄回。然后国王会用他的钥匙打开他的锁，把保险箱和皇后的锁一起送回去。然后她可以用自己的钥匙打开盒子，拿到宝石。

这里两把锁是两种加密的替身，两把钥匙代表相应的解密。该消息将用发送者的加密函数加密，发送给接收者，用接收者的加密函数加密，发送回发送者，用发送者的解密函数解密，发送回接收者，用接收者的解密函数解密。这意味着消息被发送3次，因此得名*三重通过协议*。

***** 我们来分解一下。设消息是M，桑德拉的加密和解密函数是S和S’，丽娃的加密和解密函数是R and R’。在第一次传递中，桑德拉用她的加密函数S加密了消息M，并将消息M发送给丽娃。在第二次传递中，丽娃用她自己的加密函数R加密消息SM，并将双重加密的消息RSM发送回桑德拉。在第三次传递中，Sandra将她的解密函数S '应用于消息RSM以获得S'RSM。这是为了移除S加密。只有当R和S交换，或者S和R交换时，它才会这样做。这意味着S'RSM = RS'SM = RM。这让丽娃解除了她的加密，阅读信息。

因此，为了让这种三重方案发挥作用，我们需要找到一个可交换的加密函数，或者两个可以相互交换的加密函数。我能马上想到3种交换加密函数:加法、乘法和异或。很容易想象一种加密，其中有一个与消息长度相同的密钥，加密包括将密钥逐字节添加到消息中，或将消息字节乘以密钥字节，或将消息与密钥进行异或运算。这些都是一次性密码本的简单形式。

这些都不安全。如果Emily设法获得所有三条加密信息，她就可以轻松地解除加密。如果函数是加法，则3条消息是M+S、M+S+R和M+R。如果Emily将第一条和第三条消息相加，并减去第二条消息，则她得到(M+S)+(M+R)-(M+S+R) = M。结果正好是M。当加密函数是乘法时，同样的方法也适用。这3个消息是(M×S)、(M×R)和(M×S×R)。再次取(M×S)×(M×R)÷(M×S×R)得到M。当加密函数是异或时，求M甚至更简单，因为异或是它自己的逆。简单地将3条加密的消息异或在一起，结果就是原始消息，(m⊕s)⊕(m⊕r)⊕(m⊕s⊕r)= m

互换的两个加密函数是替换和换位。这些也是没有安全感的。由于Emily将在换位之前和之后都看到消息，所以她可以很容易地确定换位。

那么，所需要的是一对互换的加密函数S和R，并且使得Emily不能确定M，即使她有SM、RSM和RM。

## 16.1沙米尔法

Shamir对这个问题的解决方案是使用幂运算。设p是一个大素数，比如在300到600个十进制数字的范围内。桑德拉将选择一个加密指数s。对应的解密指数是s ′,使得ss′≡1(mod p-1)。这是根据费马小定理得出的，如果0 < a < p，那么a <sup class="fm-superscript">p-1</sup> ≡1 (mod p)。14.4.2节描述了如何选择素数p，15.4节描述了如何确定s’。以同样的方式，丽娃选择她的加密和解密指数，r和r’。两次加密互换是因为(M<sup class="fm-superscript">s</sup>)<sup class="fm-superscript">r</sup>= M<sup class="fm-superscript">Sr</sup>= M<sup class="fm-superscript">RS</sup>=(M<sup class="fm-superscript">r</sup>)<sup class="fm-superscript">s</sup>。

桑德拉计算(M <sup class="fm-superscript">s</sup> mod p)并把它发送给丽娃。丽娃计算(M <sup class="fm-superscript">sr</sup> mod p)并将其发送回桑德拉。桑德拉计算(M<sup class="fm-superscript">SRS</sup>' mod p)=(M<sup class="fm-superscript">r</sup>mod p)并将其发送回丽娃，后者最终计算(M <sup class="fm-superscript">rr</sup> ' mod p) = M，这就是原始消息。该方法被认为是安全的，因为确定s或r需要解决离散对数问题。正如14.4节所讨论的，这个问题在计算上是困难的。没有已知的计算上可行的算法。

这个方法非常慢。所有这些大数的指数运算和模约简都需要大量的计算。下一节将描述一个解决方案的尝试。

## 16.2梅西-大村

*梅西-大村* 法是苏黎世联邦理工学院的詹姆斯·梅西和加州大学洛杉矶分校的吉姆·k·大村于1982年发明的。(他的名字在专利上被列为吉米·大村。他是我在麻省理工学院的同学，虽然我不记得他了。)Massey-Omura 系统基本上与Shamir系统相同，除了模数是2 <sup class="fm-superscript">k</sup> 的形式。这意味着余数模2 <sup class="fm-superscript">k</sup> 可以简单地通过取数的低阶k位来计算。这比计算余数模p要快得多，余数模p基本上是通过使用这些300到600位数的长除法来完成的。

在计算机械协会(ACM)和电气和电子工程师协会(IEEE )的出版物中，关于哪种方法更快的问题争论了好几年。

## 16.3离散对数

Diffie-Hellman密钥交换的 安全性、Shamir三重通过协议和Massey-Omura 方法都依赖于解决离散对数问题的难度。这个问题的三种流行算法是穷举算法，好到10 <sup class="fm-superscript">12</sup> ，丹尼尔·桑克斯的 小步大步算法，好到10 <sup class="fm-superscript">18</sup> ，约翰·波拉德的 rho算法，好到10 <sup class="fm-superscript">22</sup> 。但是，我们需要一个适合10 <sup class="fm-superscript">300</sup> 的算法。为了让大家感受一下离散对数有多难，让我们来看一个求解它的综合方法。这不是你在家里用电脑就能做到的。它需要一台大容量存储的大型机，或者一个由许多协同工作的pc机组成的网络。或者，你可以跳过这一节，直接接受离散对数问题很难的事实。

### 16.3.1对数

从考虑计算机出现之前人们如何计算普通对数开始 。一种方法是取一个像b = 1.000001这样的数，然后费力地取它的连续幂。你会发现b <sup class="fm-superscript">693148</sup> 是最接近2的幂，b <sup class="fm-superscript">2302586</sup> 是最接近10的幂。那么你就会知道log <sub class="fm-subscript">10</sub> (2)非常接近693148/2302586，也就是. 3010302。正确的值是. 3010300，所以这个方法给出了一个很好的近似值。

你可以在一个环中做同样的事情，比如整数对某个素数p取模。假设桑德拉发送消息6 mod 13，丽娃返回消息7 mod 13。艾米丽想知道丽娃用什么指数来加密。您将使用模数13的原始根，而不是1.000001的幂，例如2。有了这么小的模数，埃米莉可以很容易地计算出2的13次方。

![16-unnumb-1](Images/16-unnumb-1.png)

艾米丽现在知道桑德拉寄出了2张 <sup class="fm-superscript">5张</sup>，丽娃寄回了2张 <sup class="fm-superscript">11张</sup>。所以(2<sup class="fm-superscript">5</sup>)<sup class="fm-superscript">r</sup>≡2<sup class="fm-superscript">5r</sup>≡2<sup class="fm-superscript">11</sup>(mod 13)。这意味着5r≡11 (mod 12)。你可以用脑子解决这个问题。只要想想11+12 = 23，23+12 = 35。因为35是5的倍数，即5×7，这意味着r必须是7。可以用手摇计算器查一下，6 <sup class="fm-superscript">7</sup> = 279936≡7 (mod 13)。桑德拉寄出了6张，丽娃寄回了7张，所以这张支票与相符。

### 质数的幂

穷举 枚举给了Emily一种搜索方式，但是当p很大的时候那就不行了。让我们试试约翰·波拉德的 *rho算法*中的一个想法。第一步是生成模p的多个幂序列，并寻找重复。Emily可以同时使用几个原始根，每个核心一个根。现在让我们加倍。如果b是以p为模的本原根，她可以计算出b <sup class="fm-superscript">2</sup> ，b <sup class="fm-superscript">3</sup> ，b <sup class="fm-superscript">4</sup> ，b <sup class="fm-superscript">5</sup> ，...(mod p)和b <sup class="fm-superscript">2</sup> ，b <sup class="fm-superscript">4</sup> ，b <sup class="fm-superscript">8</sup> ，b <sup class="fm-superscript">16</sup> ，...(mod p)在另一个处理器上。艾米莉使用的每个原始根都有两套独立的异能序列。

除了原始根，艾米莉还可以直接查。桑德拉发送短信，丽娃回复短信。艾米丽可以生成序列(SM) <sup class="fm-superscript">2</sup> 、(SM) <sup class="fm-superscript">3</sup> 、(SM) <sup class="fm-superscript">4</sup> 、(SM) <sup class="fm-superscript">5</sup> ，...以及(SM) <sup class="fm-superscript">2</sup> 、(SM) <sup class="fm-superscript">4</sup> 、(SM) <sup class="fm-superscript">8</sup> 、(SM) <sup class="fm-superscript">16</sup> 、...，对于RSM也是如此。这给了艾米丽四种不同的能力。

除了这些有序的异能序列，她还可以生成一些无序的序列。这些俗称*乱走* 或者*醉走* 。一种方法是将最后产生的功率平方，然后乘以之前的一个功率。艾米莉可以随机选择早期异能，或者她可以使用列表中的中间元素。比如说，假设她已经拥有了异能x，x <sup class="fm-superscript">2</sup> ，x <sup class="fm-superscript">4</sup> ，x <sup class="fm-superscript">8</sup> 和x <sup class="fm-superscript">16</sup> 。对于下一次幂，她可以平方x <sup class="fm-superscript">16</sup> 得到x <sup class="fm-superscript">32</sup> ，然后乘以比如说x <sup class="fm-superscript">2</sup> 得到x <sup class="fm-superscript">34</sup> 。对于下面的幂，她将乘x <sup class="fm-superscript">34</sup> 得到x <sup class="fm-superscript">68</sup> ，然后乘以另一个列表元素，比如x <sup class="fm-superscript">8</sup> ，得到x <sup class="fm-superscript">76</sup> 。诸如此类。

Emily可以产生的另一种形式的随机游走使用2或3个素数。每个基素数应该是一个本原根。从这些素数的乘积开始。为了生成下一个乘积，她会随机选择一个素数，然后乘以它。艾米莉进行的序列越多，她就会越早开始得到 的结果。

### 16.3.3碰撞

好的 ，现在艾米丽有了所有这些序列。然后呢？她在寻找出现在两个列表中的同一个号码。这叫做*碰撞* ，或者*碰撞* 。假设她找到3<sup class="fm-superscript">172964</sup>≡103<sup class="fm-superscript">4298755</sup>(mod p)。这让她通过求解同余式172964r≡4298755 (mod p-1)将103表示为3的幂(mod p)。第15.4节描述了该方法。一旦她积累了足够多的崩溃，她可以建立一个链，例如RSM≡19 <sup class="fm-superscript">a</sup> ，19≡773 <sup class="fm-superscript">b</sup> ，773≡131 <sup class="fm-superscript">c</sup> ，...，103 <sup class="fm-superscript">y</sup> ≡(SM) <sup class="fm-superscript">z</sup> 。将所有指数乘以模p-1，她将得到RSM ≦( SM)<sup class="fm-superscript">r</sup>(mod p)。指数r是丽娃的加密函数。艾米丽破解了密码。

那并不像听起来那么简单。当p是一个300位数的质数时，在她开始看到任何崩溃之前，她需要10的150次方个T2。如果艾米丽有1，000，000个处理器以每秒1，000，000次的速度运行，她每年可能产生3×10 <sup class="fm-superscript">19</sup> 。这意味着她将需要大约10年才能看到任何结果，而在她能够建立这样一个链条之前，时间将会更长。此外，它将占用10个 <sup class="fm-superscript">150个</sup>字节的 存储空间。

### 16.3.4保理

代替搜索崩溃的 ，每次产生新的电力时，艾米丽可以尝试以p为模因式分解它的余数。假设她成功地因式分解97<sup class="fm-superscript">a</sup>(mod p)的余数，并找到97<sup class="fm-superscript">a</sup>≡11<sup class="fm-superscript">b</sup>29<sup class="fm-superscript">c</sup>83<sup class="fm-superscript">d</sup>(mod p)。她能解出97的同余。设a模p-1的乘法逆为a’。把同余提高到a的幂。97<sup class="fm-superscript">aa</sup>'≡97≡11<sup class="fm-superscript">b</sup>29<sup class="fm-superscript">c</sup>83<sup class="fm-superscript">d</sup>)<sup class="fm-superscript">a</sup>'(mod p)。在将所有的指数相乘并以p-1为模对它们进行归约之后，对于某些值e、f和g，结果是97≡11<sup class="fm-superscript">e</sup>29<sup class="fm-superscript">f</sup>83<sup class="fm-superscript">g</sup>(mod p)(如果p有300位，实际值可以达到300位)。)一旦她有了一个基本素数的表达式，在这种情况下是97，她就可以将该值代入所有的因式分解的乘积，既包括她已经有的乘积，也包括她以后将找到的乘积。

艾米莉将无法计算出每种能力的余数。因式分解一个300位数非常困难，意味着非常耗时。最好的策略是选择一个固定的素数基集F(B)，比如所有的素数都达到B = 10 <sup class="fm-superscript">6</sup> ，或者可能达到B = 10 <sup class="fm-superscript">7</sup> 。F(B)称为*因子基* 。尝试仅使用因数库中的质数来因数化每个幂。可以这样分解的数字称为 *B-smooth* 。随着数字越来越大，B-smooth的比例越来越小。在300位数中， B平滑数很少。当艾米丽找到每一个因子时，数字中未被因子化的部分就会缩小。如果她已经尝试了基本集合中的所有素数，并且还剩下一些未因子化的数，她就不应该再尝试因子化它了。更有效的方法是放弃这种能力，转而使用下一种能力。

下面是Emily必须做的事情:继续生成乘积并因式分解它们的余数模p。只保留B-smooth数，丢弃其余的。检查B-smooth数字中的崩溃。每次发现崩溃时，求解乘积中最大素数的同余，这样就需要越来越少的基素数来表示每个乘积。她可能会保留一个或多个处理器专门用于这个任务。

设q <sup class="fm-superscript">n</sup> 是一个素数的幂，设其余模p为x，试着用基集合B中的素数对x进行因子分解，如果x不是B-光滑的，试着对数字x+p，x+2p，x+3p，...对301位或302位的数字进行因式分解并不比对300位的数字进行因式分解困难多少。为每种残留物设定一个固定的试验次数，比如10次试验。

当她产生这些能力时，她需要特别强调SM和RSM。记住，这个练习的目标是找到指数r，使得(SM) <sup class="fm-superscript">r</sup> ≡RSM (mod p)。在她用基素数的幂表示SM和RSM之前，她不能这样做。首先，她应该开发SM和RSM的多个幂序列。一旦她成功地找到了这样一个表达式，她就在这个表达式中寻找那些还没有用较小素数的幂来表示的素数。接下来把重点放在这些质数上。继续，直到SM和RSM都表示为单个素数的幂。她现在可以使用第15.3.2节的 方法找到r。

### 16.3.5估算

假设 她用了10个 <sup class="fm-superscript">6个</sup>基素数，也就是直到B = 15,485,863的素数。用一个素数来表达所有这些将需要10个 <sup class="fm-superscript">6个</sup>同余式。存储这些需要10 <sup class="fm-superscript">6</sup> ×10 <sup class="fm-superscript">6</sup> 的指数矩阵。矩阵最初是稀疏的，但随着求解的进行，它会变得密集，因此稀疏矩阵技术不会有好处。每个指数都是一个300位数。这需要大约10 <sup class="fm-superscript">15</sup> 字节或者一*Pb*T16】的存储空间。截至本文撰写之时(2022年3月)，世界上最大的超级计算机是橡树岭国家实验室的峰会计算机，它拥有2.76千兆字节的可寻址存储。

运行时间显然取决于找到 B-smooth数需要多长时间。B-smooth数的密度由de Bruijn函数ψ(p，B)给出，它给出了小于p的B-smooth整数的个数，它是由荷兰数学家Nicolaas Govert de Bruijn 研究的。ψ(x，x <sup class="fm-superscript">1/u</sup> 的值由x ρ (u)近似得出，其中 ρ (u)是精算师卡尔·迪克曼发明的迪克曼函数。迪克曼函数 ρ (u)近似为u <sup class="fm-superscript">-u</sup> 。在这种情况下，x = 10 <sup class="fm-superscript">300</sup> ，x <sup class="fm-superscript">1/u</sup> = 15，485，863，因此u = 41.725。因此，将花费大约41.725<sup class="fm-superscript">41.725</sup>= 4.08×10<sup class="fm-superscript">67</sup>来尝试找到每个B-smooth数。

总共需要超过10次 <sup class="fm-superscript">73次</sup>试验才能找到10次 <sup class="fm-superscript">6次</sup> B级平滑能力。因式分解每一个数字可能会占用多达10个 <sup class="fm-superscript">6个</sup>8个试分，所以总共有10个 <sup class="fm-superscript">79个</sup>试分。由于数字是300位，每个试除法将进行300次运算的倍数。总共称之为10 <sup class="fm-superscript">82</sup> 操作。对于崩溃方法来说，这比10 <sup class="fm-superscript">150</sup> 是一个巨大的进步，但是对于现在的计算机来说仍然遥不可及。

这表明，在可预见的未来，也许是未来20到30年，300位数已经足够了。随着量子计算机的发展，这种情况可能会改变，但目前300位数的T2 T3 T4 T5是安全的。

## 16.4矩阵三遍协议

sha mir和Massey-Omura 三遍算法的方法都使用取幂运算。三遍算法的另一种方法是使用矩阵。我们以前在希尔密码15.1节看到过这种情况。消息被分成多个块。每个块被视为模256的整数向量。这个向量乘以一个模256的整数的可逆方阵，或者在左边或者在右边。对于三遍版本，桑德拉将具有用于加密的矩阵S和用于解密的矩阵S’，而丽娃将具有加密矩阵R和解密矩阵R’。这些矩阵不是模256的整数上的，而是256个元素的一个环 ***R*** 上的，报文的字符被当作这个环的元素。设消息块为M，于是桑德拉将SM发送给丽娃，丽娃将RSM发回给桑德拉，桑德拉用S '解密得到S'RSM = RM。现在丽娃可以用R '解密，即R'RM = M

棘手的部分是使S'RSM = RM。矩阵乘法是不可交换的，所以桑德拉和丽娃需要选择相互交换的特殊矩阵S和R。需要明确的是，S和R不是交换矩阵。如果随机选择一个矩阵X，几乎可以确定SX≦XS和RX≦XR。这是本质点，所以我再重复一遍，S和R不是交换矩阵。它们不能与大多数其他矩阵互换。他们互相通勤。

### 16.4.1交换矩阵族

桑德拉、T2和丽娃需要大量供应这些基质，这样艾米丽就不能简单地全部尝试。这意味着他们需要一个大的交换矩阵家族**来为消息的每个块选择矩阵。**

 **注**ғ**是交换矩阵族，不是交换矩阵族。重要的是要理解是族是可交换的，而不是矩阵本身。几乎所有在ғ中的矩阵都是可交换的。它们会相互交换，但不会与其他矩阵交换。

构造交换族最简单的方法是从任意可逆矩阵，F开始，取其幂，F <sup class="fm-superscript">0</sup> ，F <sup class="fm-superscript">1</sup> ，F <sup class="fm-superscript">2</sup> ，F <sup class="fm-superscript">3</sup> ，...，其中F <sup class="fm-superscript">0</sup> 为单位矩阵I，F <sup class="fm-superscript">1</sup> = F .称f为家族**【ғ**的*生成矩阵* 。

桑德拉和丽娃将分别需要为消息的每个块使用不同的矩阵，否则，给定一组足够的具有已知明文的消息块 M <sub class="fm-subscript">i</sub> ，艾米丽可能会解线性方程组 R(SM <sub class="fm-subscript">i</sub> ) = RSM <sub class="fm-subscript">i</sub> 。

### 16.4.2乘法顺序

到 使族**ғ**大，需要寻找或构造一个高乘法阶的生成矩阵f。即F <sup class="fm-superscript">n</sup> = I的最小整数n > 0需要大，至少10 <sup class="fm-superscript">25</sup> ，但最好大一些。如果矩阵F是可逆的，这样的n将一直存在，F的乘法逆F’是F <sup class="fm-superscript">n-1</sup> 。15.8节给出了求可逆矩阵的方法。确定F的乘法阶数是有点艺术的，在F <sup class="fm-superscript">n</sup> = I之前取连续的幂F显然是不可行的，在n > 10 <sup class="fm-superscript">25</sup> 的时候肯定不行。但这是可以做到的。

求乘法序，从1×1矩阵开始，即环元素。看看这些元素的乘法顺序。这些很容易通过枚举找到，因为n的最大可能值是255。可能的值是2、3、7、15、31、63、127和255。较大矩阵的乘法阶数往往是这些值的倍数。

假设环元素的乘法阶数恰好是2，7，31。当你尝试2×2矩阵时，首先将每个矩阵A提升到单元素阶的倍数，比如2 <sup class="fm-superscript">4</sup> 7 <sup class="fm-superscript">2</sup> 31 = 24304。然后列举B = A <sup class="fm-superscript">24304</sup> 的幂。假设你发现B <sup class="fm-superscript">52</sup> = I .你现在肯定知道A的乘法阶m整除x = 24304×52 = 2<sup class="fm-superscript">6</sup>7<sup class="fm-superscript">2</sup>13×31，并且它是2 <sup class="fm-superscript">6</sup> 13的倍数。接下来你应该试试一个 <sup class="fm-superscript">x/7</sup> 和一个 <sup class="fm-superscript">x/31</sup> 看看它们是否是I。如果一个 <sup class="fm-superscript">x/7</sup> 是I，你接着试试一个 <sup class="fm-superscript">x/49</sup> 。在这种情况下，最高乘法阶数可能是2 <sup class="fm-superscript">6</sup> 7×13×31。

你接下来处理3×3矩阵。如果除了2、3、7、13和31之外，没有其他素数因子出现在2×2矩阵的乘法阶中，那么好的起始指数可能是x = 2<sup class="fm-superscript">8</sup>7<sup class="fm-superscript">2</sup>13<sup class="fm-superscript">2</sup>31<sup class="fm-superscript">2</sup>。枚举B = A <sup class="fm-superscript">x</sup> 的连续幂，并重复缩小指数的过程。随着矩阵变得越来越大，乘法阶数可能会增加一个很大的因子，以至于无法通过枚举来找到。在这种情况下，你需要猜测将要出现的新的质因数。

注意乘法顺序中出现的模式。这需要一些侦查工作。例如，假设出现2个 <sup class="fm-superscript">3个</sup> -1，2个 <sup class="fm-superscript">6个</sup> -1，2个 <sup class="fm-superscript">9个</sup> -1和2个 <sup class="fm-superscript">12个</sup> -1。你不会直接看到这些，因为它们并不都是质数。2 <sup class="fm-superscript">6</sup> -1 = 63 = 3 <sup class="fm-superscript">2</sup> 7，2 <sup class="fm-superscript">9</sup> -1 = 511 = 7×73和2<sup class="fm-superscript">12</sup>-1 = 4095 = 3<sup class="fm-superscript">2</sup>5×7×13。因此，在质因数中找到13是“真实”因数可能是2 <sup class="fm-superscript">12</sup> -1的线索，而找到73是2 <sup class="fm-superscript">9</sup> -1是因数的强烈指示。如果你看到2 <sup class="fm-superscript">3</sup> -1，2 <sup class="fm-superscript">6</sup> -1，2 <sup class="fm-superscript">9</sup> -1，2 <sup class="fm-superscript">12</sup> -1都出现了，你应该期待2 <sup class="fm-superscript">15</sup> -1很快出现。如果这些都出现的话，它们每一个都是可以被7整除的，那么乘法的顺序就会被7<sup class="fm-superscript">4</sup>T37】整除T34】。

### 16.4.3最大订单

桑德拉的 目标是让这个家庭**ғ**尽可能的大，这样她和里瓦就可以对矩阵s和r有更多的选择。一个有用的技巧是观察因子集差异的乘法顺序。例如，如果A的乘法阶数是19m，B的乘法阶数是23m，那么AB的乘法阶数可能正好是19×23m = 437m。如果这不起作用，那么A'B或AB '可能有乘法阶437m。

如果可能的话，桑德拉应该选择一个生成矩阵 F，它的乘法阶有一个大的质因数，比如说m > 10 <sup class="fm-superscript">35</sup> ，以防止Silver-Pohlig-Hellman攻击(第14.4节)。桑德拉将需要对不同的n进行2 <sup class="fm-superscript">n</sup> -1的因式分解，以找到具有大质因数的n，然后通过尝试连续更大的 矩阵，找到其乘法阶数可被2 <sup class="fm-superscript">n</sup> -1之一整除的生成矩阵。

### 艾米莉袭击事件

假设桑德拉选择了f和**ғ**，并且她已经给里瓦发了一条消息。由于桑德拉和里瓦通过公共信道(例如互联网)进行通信，假设艾米丽知道f、**、SM、RSM和RM。她的目标是找到R或S，所以她有两次机会。让我们集中讨论艾米丽可能如何找到r。艾米丽知道关于r的两件事。首先，她知道SM和RSM的值，所以这给了她在r的n个 <sup class="fm-superscript">2个</sup>未知元素中的一组n个线性方程。第二，她知道r在家族**中，所以它必须与f交换，即RF = FR。如果环 ***R*** 是可换的，那么这就给了她R的n <sup class="fm-superscript">2</sup> 个元素中的n(n-1)个额外的线性方程组****

 ****这是因为矩阵方程RF = FR的左边产生RF形式的项的和，其中R是R的未知元素，f是f的已知元素。右边产生FR形式的项。由于环是可换的，左边的rf项可以转换成fr形式，并与右边的RF项组合起来形成线性方程。

有n个未知数n个线性方程2个T2，n个未知数T3个线性方程2个T4，要解这些线性方程并找到r似乎是件轻而易举的事，并不那么容易。回想一下15.3.1节，有强同余和弱同余。这同样适用于任何大小不是素数的有限环上的线性方程。环的素数因子越多，弱方程的潜力就越大。在目前的情况下，环的大小是2 <sup class="fm-superscript">8</sup> ，有8个质因数，所以许多线性方程很可能是弱的。如果环 ***R*** 选择得当，矩阵的典型大小可能是30×30，或者128×128，或者甚至256×256，如果环选择不当。即使有一个精心选择的环，即使有一半的方程是强的，你也会期望对30×30 = 900的方程组有至少2个 <sup class="fm-superscript">450</sup> 解。实际上，解的数量要大得多，因为可能有4个、8个或可能16个解的方程。

艾米丽有个好消息。艾米丽可以求解R '而不是R，她得到的2个 <sup class="fm-superscript">450</sup> 或更多解中的任何一个都将是R的有效逆，让她通过 R'RM = M获得消息

### 16.4.5非交换环

看来珊卓拉和丽娃沉没了。艾米丽赢得了这场战斗。

对这种攻击的一个可能的回答是桑德拉和丽娃使用一个非交换环。非交换环的两个例子是矩阵和四元数(15.7.2节)。你可以形成矩阵，它的元素本身是矩阵或四元数，或者相反，四元数的系数是矩阵或四元数。这些都不是好的选择。你需要把它们做得非常大，以产生高乘法阶数的矩阵。

更好的方法是使用第15.7节的技术构建自己的环***【N】***。你应该选择一个有许多元素的环，这些元素(1)是可逆的，(2)具有高的乘法阶数，以及(3)是非交换的。找到一枚具备所有这些特征的戒指是一个微妙的平衡。例如，具有最大乘法阶数的元素的环(对于256元素的环是255)不能有任何非交换元素。如果你能找到一个环，其中一半的元素是可逆的，一半的乘法阶数等于环大小的一半，一半是不可交换的， *dayenu* (这就足够了)。你不可能同时实现这三个目标，但是你可以超越其中一些，同时接近其他的。

对于非交换环，矩阵方程rf = fr不能再线性化，因为不再确定RF = FR。相反，矩阵方程导致一组*双线性* 方程。双线性方程中的一般项采用axb的形式，其中a和b是环的元素，x是要确定其值的变量。虽然线性方程可以使用简单的系统方法求解，即高斯消去法，但双线性方程没有这样的方法。连解ax+xb = c这种简单的单变量x的方程都没有通用的方法，所以解环上的双线性方程是 “不可能的。”

### 16.4.6求解双线性方程

那个 说，我现在给你演示如何解双线性方程。诀窍是改变环中元素的表示 ***N*** 。我们已经看到了几个如何做到这一点的例子。在环 ***R13*** 中，元素表示为*a*+*b*√13。高斯整数表示为a+bi。四元数表示为a+bi+cj+dk。这里，I，j和k是抽象单位，它们的乘积决定了环的行为，a，b，c和d是环的交换元素。四元数可以不可交换是因为单位的乘法运算不可交换，即ij≦Ji，ik≦ki和JK≦kj。只有一个单位，高斯整数必然是可换的。

诀窍是*通过寻找非交换环 ***N*** 的一个表示来线性化*双线性方程。这很容易做到。首先将 ***N*** 的元素分成A和B两组，其中A包含有表示的元素，B包含剩余的元素。最初A是空的，B包含环的所有元素。首先取交换元素并把它们移入集合a。这些环元素将表示它们自己。它们是表示中的“a”项。选择任意剩余的可逆元素作为单元I .取所有可以表示为a+bi的环元素，其中A和B是环的可交换元素，将它们从集合B移到集合A .到目前为止，A的所有元素仍然是可交换的.

集合B不能为空，因为 ***N*** 不可交换。我们已经注意到只有一个单位的环，像高斯整数，一定是可换的。因此，从集合B中取出第二个可逆元素，并将其称为第二个单元j。这一次，您取出可以表示为a+bi+cj的所有元素，并将它们从集合B移动到集合a。集合B中可能仍有环形元素。在这种情况下，您将重复这些步骤，但为简单起见，我们假设(1)只需要两个单元；(2)环中的所有元素都可以表示为a+bi+cj，其中I和j是抽象单位；以及(3) a，b，c是环 ***N*** 的交换元。在实践中，您得到的单位数可能取决于您对I和j的选择，因此您应该进行多次试验以得到最少的单位。这很重要，因为更多的单位意味着线性化时会有更多的方程。由于求解一组线性方程所需的时间与方程数量的立方成正比，因此影响很大。

我们回到矩阵方程RF = FR，把环元素放成a+bi+cj的形式。 ***R*** 的未知元素将具有x+yi+zj的形式，其中x、y和z是未知的交换环元素。现在矩阵乘积RF的一项将具有以下形式

![16-unnumb-1-equation-16-2](Images/16-unnumb-1-equation-16-2.png)

其中i <sup class="fm-superscript">2</sup> ，j <sup class="fm-superscript">2</sup> ，ij和ji将进一步展开为1，I和j的线性组合，如d+ei+fj。当然，实际的扩展将取决于环的选择以及哪些元素被选作I和j。

矩阵产品FR中的术语也必须如此。最后，你得到的不是900个方程中的900个未知数，而是2700个方程中的2700个未知数。这使得错误答案的数量从2个 <sup class="fm-superscript">450个</sup>增加到2个 <sup class="fm-superscript">1350个</sup>。这对艾米丽来说是个坏消息。假解不允许她恢复 消息。

### 16.4.7弱者

家族**ғ**会包括一些弱项，比如对角矩阵和三角矩阵，艾米莉很容易就能求逆。这些弱者不应该被用作钥匙。从**ғ**中选择矩阵时，验证主对角线的上方和下方至少有一个非零元素。为了快速测试，只需验证X <sub class="fm-subscript">12</sub> ，X <sub class="fm-subscript">13</sub> 和X <sub class="fm-subscript">23</sub> 中至少有一个非零，X <sub class="fm-subscript">21</sub> ，X <sub class="fm-subscript">31</sub> 和X <sub class="fm-subscript">32</sub> 中至少有一个非零。否则拒绝X，重新选择。被拒绝的矩阵百分比 可以忽略不计。

### 16.4.8快速制作

用矩阵代替幂运算的优势可能还不清楚。从家族**ғ**中选择矩阵s或r需要取生成矩阵 F的大幂。这比取大整数的大幂有什么更好或更快的吗？区别在于准备。在沙米尔和梅西-奥姆拉方法中，桑德拉和丽娃必须取各自从对方那里得到的数字，并对其进行大幂运算。因为他们事先不知道那个数，所以他们不能做任何准备来加速幂运算。

然而，利用矩阵方法，生成矩阵F是预先已知的。桑德拉和丽娃都可以预先生成一些F的幂，然后将这个矩阵幂的基础集合保留在手边，这样他们就可以通过1或2次矩阵乘法来生成一个新的F的幂。首先，他们可以生成一组16个矩阵F，F <sup class="fm-superscript">2</sup> ，F <sup class="fm-superscript">4</sup> ，F <sup class="fm-superscript">8</sup> ，...，F <sup class="fm-superscript">32768</sup> 仅使用15次矩阵乘法。

如果他们只做那么多，艾米丽也会做的。她将拥有与桑德拉和丽娃相同的矩阵基集，因此她可以轻松确定她们的加密矩阵S和r。为了防止这种情况，桑德拉和丽娃需要随机化她们的矩阵集。他们通过随机选择两个矩阵并将它们相乘来实现。这个产品将取代基础组中的两个矩阵之一。桑德拉和丽娃独立完成这项工作。谁也不知道另一方选择了F的哪个幂。

这种替换操作应该在设置期间重复很多次，比如说1000次，以使每一方的矩阵集是完全随机的。如果1000看起来太多，请记住，在使用300位素数的Shamir方法中，每次取幂将需要大约1000次乘法和1000次模约简。桑德拉和丽娃也需要保持他们矩阵的逆矩阵。每次他们乘以F的两个幂，他们需要乘以F '的相应幂，这样他们就不需要求任何幂的倒数。

在发送第一条消息之前，只需执行一次设置步骤，即生成基本集。当你有了这组扩展的生成矩阵，你就可以用一次矩阵乘法和一次矩阵求逆来生成一个发送消息的矩阵。你从你的基集中随机选择两个不同的矩阵F <sup class="fm-superscript">a</sup> 和F <sup class="fm-superscript">b</sup> ，相乘得到F <sup class="fm-superscript">a+b</sup> ，然后用F <sup class="fm-superscript">a+b</sup> 代替F <sup class="fm-superscript">a</sup> 这样你每次都会生成不同的矩阵。

使用这种技术，我发现对于30×30矩阵和1024位模数，矩阵方法的速度是沙米尔或梅西-奥姆拉 求幂 方法的2100倍。

## 16.5双面三通道协议

前面矩阵方法中的 矩阵乘法可以在左侧或右侧进行，这意味着信息可以被加密为SM或MS，也可以在两侧进行乘法。在这种情况下，消息被拆分成n个 <sup xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-superscript">2个</sup>字符的块，并且有两个独立的n×n矩阵族，T9】ғ和**ɠ**，生成矩阵f和g。桑德拉将使用来自**ғ**的矩阵s和来自**ɠ**的矩阵t对消息进行加密，而里瓦将使用

桑德拉给丽娃发了一条加密短信。丽娃超级解密并发回RSMTQ。桑德拉通过使用逆矩阵S '和T '删除她的加密，将S'RSMTQT' = RMQ发送回丽娃，后者使用她的逆矩阵R '和Q '，将其解密为R'RMQQ' = M。由于其块大小较大，双面方法对于短消息不实用，但对于长消息，它比单面方法快得多，因为在每个块中得到n个 <sup class="fm-superscript">2个</sup>字符，而不是n个字符。对于30×30矩阵，它的速度是单侧方法的15倍，因此是Shamir或Massey-Omura方法的30，000倍。

艾米莉必须同时求解两个矩阵。设艾米丽截取的3个矩阵称为X，Y，Z，即X = SMT，Y = RSMTQ，Z = RMQ。艾米莉知道Y = RXQ，Z = S'YT '。看起来艾米莉将需要求解非交换环 ***N*** 上的一大组二次方程，这比求解线性或双线性方程要困难得多。但是，如果这些方程分别乘以R’，Q’，S和T，就变成R’y = XQ，YQ’= RX，SZ = YT’，ZT = S’y。这些矩阵方程相乘得到双线性方程。我们在16.4.6节看到了如何求解双线性方程。

如果艾米丽能同时找到R '和Q '，或者她能同时找到S '和T '，她就能恢复M。她可以选择解这四个方程的前两个或后两个。让我们继续30×30矩阵的例子，集中精力求解R'Y = XQ。R '中有900个未知数，q中还有900个未知数，这个矩阵方程在这1800个未知数中提供了900个双线性方程。艾米莉也知道r '在**中，q在**中，所以R'F = FR '和QG = GQ。其中每一个都会产生额外的30×29 = 870个双线性方程。这给了艾米丽总共2640个双线性方程的1800个未知数。这些方程可以通过改变环元素的表示来线性化。****

 ****这导致了5400个未知数的7920个线性方程。当方程比未知数多时，这个系统被称为*超定* 。当Emily简化方程组时，多余的方程就消失了。也就是说，7920×5400矩阵的许多行变成全零。它们可以被移到矩阵的底部并被忽略。最后，出现了与单方面情况相同的困难，即有多种解决方案。由于双侧方程是超定的，它们比单侧方程更强。另一方面，有两倍多的未知数。目前还不清楚哪种方法最终更强。你可能会简单地选择双面方法，因为它要快得多。 ****************