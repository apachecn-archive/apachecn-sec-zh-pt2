# 15种矩阵方法

本章涵盖了

*   使用整数矩阵或环元素矩阵乘法的密码
*   用大整数和小整数相乘的密码
*   求解线性同余
*   构造环和可逆矩阵

矩阵是一种非常适合加密的工具，因为它们可以在一次操作中加密任意大的文本块。通常，消息中的每个块都被视为一个字节向量，即以256为模的整数。

![15-unnumb-1](Images/15-unnumb-1.png)

当珊卓拉使用一个矩阵来加密讯息时，丽娃必须使用这个矩阵的逆来解密讯息。让我们从矩阵求逆的技术开始矩阵方法的讨论。

## 15.1矩阵求逆

当已知明文时，有几种方法可以求解矩阵方程，如C = AP。由于艾米丽知道P和C，但不知道A，她可以通过右乘P '得到CP' = APP' = A来解出A的方程。所以艾米丽需要求P的倒数。丽娃做的正好相反。她知道A，但不知道P，所以她需要对A求逆。将等式左乘A '，她得到A'C = A'AP = P 。

这里说明的方法具有直接获得逆矩阵的优点，而不需要其他方法所需的中间步骤回代。方法是将给定矩阵与单位矩阵并排放置在一个n×2n双宽矩阵中。仅使用*初等行运算* 将左尺寸缩减为一个单位矩阵。这些行操作应用于双矩阵的每一行，因此当左半部分从原始矩阵变为单位矩阵时，右半部分从单位矩阵变为原始矩阵的逆矩阵。

基本的行操作是(1)将一行乘以一个可逆常数，(2)交换两行，(3)从另一行中减去一行的倍数。

该算法从左上角开始，依次将原始矩阵的元素转化为单位矩阵的元素，然后从左列开始。然后对第二列进行同样的操作，依此类推。如果在任何时候算法被卡住，这意味着活动列中的所有元素都是2的倍数，或者都是13的倍数，那么矩阵是不可逆的。如果这种情况发生在Sandra身上，她需要尝试不同的矩阵a。通常在最下面一行的某个元素上加1就足够了。如果Emily遇到这种情况，她将需要n个以上的已知明文字符。这将给她一个(n+1)×n矩阵。当她应用这个算法时，逆矩阵在双宽矩阵的右上角n×n部分。

这里有一个3×3的例子。这个矩阵工作在26个字母的英文字母表 上，所以矩阵元素是模26的整数。没有分数，也没有负数。因为这是对26取模，所以不是2的倍数也不是13的倍数的每个元素都有一个乘法逆运算。这使我们可以将每一行中的第一个非零元素变成1，这样就很容易决定从任何其他行中减去一行的哪个倍数。原始矩阵是

![15-unnumb-1-equation-15-1](Images/15-unnumb-1-equation-15-1.png)

通过在右侧添加一个3×3的单位矩阵，这种格式被扩展为双倍宽格式。

![15-unnumb-1-equation-15-2](Images/15-unnumb-1-equation-15-2.png)

你马上就有麻烦了，因为任何一行中的第一个元素都不可逆。我故意这样做是为了展示一个非常有用的技巧。第1行的第一个元素是13的倍数，但不是2的倍数。第2行的第一个元素是2的倍数，但不是13的倍数。如果你简单地把第2行加到第1行，那么第一个元素就变成了19，它既不是2的倍数也不是13的倍数，因此它是可逆的。问题已解决。

![15-unnumb-1-equation-15-3](Images/15-unnumb-1-equation-15-3.png)

19的乘法逆是11模26，因为19×11 = 209≡1 (mod 26)。将第1行乘以11，将矩阵中的第一个元素变为1。

![15-unnumb-1-equation-15-4](Images/15-unnumb-1-equation-15-4.png)

现在，你可以通过从第2行减去6倍的顶行，从第3行减去10倍的顶行来完成第1列。这会将第2行和第3行中的第一个元素设置为零。

![15-unnumb-1-equation-15-5](Images/15-unnumb-1-equation-15-5.png)

第二排工作时间到了。第2行的第一个非零元素是9。9的乘法逆是3，因为9×3 = 27≡1 (mod 26)。将第2行乘以3，将该行的第一个元素变为1。

![15-unnumb-1-equation-15-6](Images/15-unnumb-1-equation-15-6.png)

这使您可以通过从第1行减去第2行，并从第3行减去第2行的25倍来完成第2列。注意双宽矩阵的左侧是如何逐渐变成单位矩阵的。

![15-unnumb-1-equation-15-7](Images/15-unnumb-1-equation-15-7.png)

差不多完成了。第3行的第一个非零值是21。21的乘法逆是5，所以你把矩阵最下面一行乘以5。

![15-unnumb-1-equation-15-8](Images/15-unnumb-1-equation-15-8.png)

现在你可以从第一行减去第三行的9倍，从第二行减去第三行的19倍，从而完成第三列。

![15-unnumb-1-equation-15-9](Images/15-unnumb-1-equation-15-9.png)

搞定。双宽矩阵的左半部分现在存放的是单位矩阵，右半部分是原矩阵的逆矩阵。您可以通过将原始矩阵乘以逆矩阵来检查这一点。结果应该是单位矩阵——它是。

![15-unnumb-1-equation-15-10](Images/15-unnumb-1-equation-15-10.png)

## 15.2转置矩阵

先说一个很简单的矩阵方法，即*转置矩阵* ，相当于数学上的*置换矩阵* 。这是一个正方形矩阵，每行和每列都正好有一个1。所有其他矩阵元素都是0。如果您希望转置一个由10个字母组成的块，您可以将该块视为大小为1×10的行矩阵，并在右侧将其乘以大小为10×10的转置矩阵。结果将是一个字母被转置的1×10矩阵。

要将一个字母从块中的位置2移动到位置5，可以将第2行第5列的元素设置为1。下面是一个4×4转置矩阵的示例，它将消息块ABCD更改为BADC。

![15-unnumb-1-equation-15-11](Images/15-unnumb-1-equation-15-11.png)

转置矩阵本身并不特别实用，但是如果你有一个矩阵M和一个转置矩阵T，你可以用矩阵MT代替M，将它们合并成一个步骤。这样，你就可以在一个操作中同时进行替换和转置。

## 15.3希尔密码

最早的基于矩阵的密码是*希尔密码* ，1929年由亨特学院的莱斯特·希尔发明，发表在*美国数学月刊*上。1924年，当时十几岁的杰克·莱文发明了一种类似的密码，后来成为北卡罗来纳州立大学的学生，并于1926年发表在一份低俗侦探杂志《弗林周刊》上。弗林*的*中的加密栏目由M. E. Ohaver 负责，他发明了分段莫尔斯(第4.4节)。巧合的是，*弗林的周刊*也是肯德尔·福斯特·克罗森发表他的许多故事的地方，在第4.4节中也有提及。莱文的整个职业生涯都在试图推翻希尔的密码，并推广自己的密码。

希尔密码对26个字母的字母表进行运算，这些字母以某种混乱的顺序从0到25进行编号。也就是说，在矩阵运算之前执行一个简单的替换。你把明文字母分成三组。这些形成一个列向量，即一个3×1的矩阵p，你把左边的这个列向量乘以一个3×3的矩阵A，然后加上一个列向量B，得到密文向量C，在矩阵符号中这写成C = AP + B，使用加法和乘法模26。最后，使用相同的字母-数字对应关系将数字转换回字母。

不幸的是，许多作者将术语*希尔密码*限定为这种密码的一个弱淡化版本。为了避免歧义，让我们给希尔密码的几种版本编号。希尔-0 是最弱的版本。你用的是标准英文字母，没有混合，省略了B向量，这样C = AP。Hill-1 稍微强一点。你仍然使用非混合字母表，但是B向量是非零的。希尔-2 是希尔最初提出的版本。你使用混合字母和非零B向量。Hill3 这与9.6.1节中的共轭矩阵双歧 密码相当。

最初发表的希尔密码Hill-2基本上是一种秘密方法密码。字母到数字的转换以及矩阵A和B都是固定的。没有钥匙。任何知道这个方法的人都可以像预期的接收者一样容易地阅读信息。大多数讨论希尔密码的书籍和网站都忽略了混合字母表，而只关注矩阵运算。如果使用从字母到数字的固定转换，这将是合理的，因为已知的字母混合可以被去除。

我们先来看case Hill-0，这里A是一个未知的n×n矩阵，向量B是0，所以C = AP。这是普通的老式矩阵乘法，我们在11.3节看到过。丽娃可以通过将密文乘以A的*逆矩阵*A’来解密消息，逆矩阵具有A’A = AA’= I的性质，其中I是*单位矩阵* 。在矩阵I中，每一个对角元素是1，并且每隔一个元素是0。单位矩阵类似于普通乘法中的数字1，也就是说，对于每个数字N，1×N = N×1 = N。对于矩阵，这可以转化为对于每个方阵A，IA = AI = A。如果Emily可以确定A’，她也可以破译消息。

希尔密码的B = 0版本容易受到已知明文攻击。如果艾米丽有n个已知明文的 <sup class="fm-superscript">2</sup> 字符，她可以将它们组成一个n×n矩阵。称这个矩阵P，称对应的密文矩阵C，那么C = AP，其中C，A，P都是n×n的整数模26的矩阵。有几种方法可以解这个矩阵方程。第15.1.1节给出了一种方法。

如果加性向量B不是全零，那么Emily只需要再多n个已知明文的字符，她就可以把B从方程中消去。多余的已知明文字符可以形成列向量P <sub class="fm-subscript">2</sub> ，对应的密文字符可以形成列向量C <sub class="fm-subscript">2</sub> 。这些向量可以这样从方程中减去:(C-C <sub class="fm-subscript">2</sub> ) = A(P-P <sub class="fm-subscript">2</sub> )。这与C = AP具有相同的形式，并且以相同的方式求解，即通过对矩阵P-P <sub class="fm-subscript">2</sub> 求逆。从n×n矩阵中减去n×1列向量，方法是从矩阵顶行的每个元素中减去向量的第一个元素，从矩阵第二行的每个元素中减去向量的第二个元素，依此类推。

![15-unnumb-1-equation-15-12](Images/15-unnumb-1-equation-15-12.png)

假设你没有已知的明文。还是有可能解决Hill-0变异的。让我们继续假设一个秘密的3×3乘法矩阵，C = AP。乘以A '，A的倒数，得到P = A'C。在消息的每个块中，块的第一个明文字符只取决于a的顶行，也就是说只有26<sup class="fm-superscript">3</sup>= 17576种可能性，所以很容易全部尝试。顶行的每个组合将确定位置1、4、7、.。。明文中。对于每个这样的组合，计算字母的频率。

您可以使用第5.9.1节中描述的高峰法将这些字母频率与标准英文字母频率进行比较。取那些具有最佳匹配的组合，比如前1%或前175个组合。通过使用逆矩阵A’的第二行和第三行，对每个块的第二个和第三个明文字母进行相同的操作。这为3行中的每一行提供了175种可能的组合。现在，您可以尝试这些组合的组合，以获得整个消息的可能重构。只有175个 <sup class="fm-superscript">3</sup> = 5.36×10 <sup class="fm-superscript">6</sup> 组合可以尝试。第1行的组合给出了每个区块中的第一个字母，第2行的组合给出了每个区块中的第二个字母，第3行的组合给出了每个区块中的第三个字母，所以每个字母都有。

现在，您可以使用三元模型频率来确定最有可能的明文。使用所有三元模型，不仅仅是3个字母的块，还包括跨块的三元模型。这与我们在第5.10节和第8.2节中使用的过程相同，所以我不会在这里重复所有的细节。如果这不能产生一个满意的结果，回到开始，并为每个字母取前2%或前350个组合。

希尔密码Hill-1具有一个秘密的3×3乘法矩阵和一个秘密的3×1加法矩阵，但是具有一个未混合的字母表，等级为3。在矩阵运算之前和之后都有关键字混合替换的情况下，它被评定为5。它可以作为一般的三元模型替换密码来解决。矩阵越大，等级越高。为了达到10的评级，矩阵必须至少为8×8，并且必须应用两次Hill-3矩阵运算。以下是步骤。(1)使用键控非线性替换将消息转换为数字形式。(2)将每个块乘以矩阵，并加上列向量。(3)对数字执行第二次非线性替换。(4)将每个块乘以第二矩阵，并添加第二列向量。(5)使用第三键控非线性替换将结果转换回字母。两个乘数矩阵可以是固定的，但是用于混合字母的3个键和2个加法列向量对于每个消息应该是变化的。称这个暗号为*。*

 *## 15.4希尔密码，计算机版本

希尔的密码太复杂了，密码员无法用手操作。希尔还发明了一种机械装置来进行加密和解密。这样做是为了满足当时的专利法，专利法允许为机器申请专利，但不允许为数学算法申请专利。然而，这种密码在实践中几乎没有用处。

今天，在计算机时代，希尔密码又变得实用了。矩阵乘法对计算机来说是小菜一碟。使用10×10矩阵代替3×3矩阵是很容易的。对于已知明文攻击，Emily需要100个字符，而不是9个已知明文字符。这几乎是不可能的，除了通过间谍活动或在战场上捕捉信息。希尔密码使用一个使用标准字母表的秘密10×10矩阵，被评为6级。希尔密码使用一个秘密的10×10矩阵，在矩阵乘法之前和之后都有密钥混合替换，其等级为8。

通过拥有多个矩阵并定期或随机地为每个块选择矩阵，您可以进一步增强希尔密码。矩阵和明文块的大小可以不同。由于矩阵乘法是不可交换的，当你乘以左边或右边的矩阵时，你几乎总是得到不同的结果。当你在左边乘时，每个明文块必须作为一个列向量，而当你在右边乘时，必须作为一个行向量。这表明你可以通过周期性地或随机地交替两边来得到一个更安全的密码。可变矩阵、可变块大小和可变边。你可以选择或混合他们。

您也可以将换位与希尔密码结合使用，但是，并不是每次换位都会提高安全性。假设您正在使用Hill-0或Hill-1变体，在矩阵乘法之后，您转置每个块中的字母。这与使用具有不同矩阵乘法器的希尔密码相同。设T代表换位。在Hill-1加密后应用T得到C = T(AP+B) = (TA)P+(TB)。你所做的就是用矩阵TA代替A，用TB代替b，Emily可以用已知的明文来解密码，她永远不会知道有一个转置。如果您希望对Hill-0或Hill-1使用换位，您必须在不同的块之间交换字母，或者您必须在不同的块中交换不同的字母。

令人惊讶的是，当您使用Hill-2或Hill-3时，情况完全相同。这是因为简单的替换和换位互换。如果S是任意简单替换，T是任意转置，M是任意消息，则S(T(M)) = T(S(M))，因此ST = TS。因此，无论您使用哪种希尔密码变体，如果您要添加一个换位步骤，您必须在不同的块之间交换字母，或者您必须在不同的块中交换不同的字母，周期地或伪随机地。

另一个想法是将消息乘以两边的矩阵。如前所述，当您将文本块的左边乘以一个矩阵时，它必须被视为一个列向量，而当您将它乘以右边时，它必须被视为一个行向量。假设您使用3×3矩阵，加法矩阵B = 0。使用单面矩阵乘法，每个密文字符的表达式有3项，每项包含一个明文字母和一个矩阵元素。对于双侧矩阵乘法，每个密文字母的表达式有9项，每项涉及一个明文字母和2个矩阵元素的乘积。所以明文字母的系数是二次的。在81个可能的二次系数中，有27个出现在这些表达式中。

对于Hill-0和Hill-1情况，Emily仍然可以使用已知的明文来求解这些方程。有简单的方法和困难的方法。困难的方法是用18个已知明文字符来求解两个3×3矩阵中18个未知元素的18个二次方程。祝你好运！

最简单的方法是将27个二次系数中的每一个视为一个独立的变量。这将方程从18个变量的二次方程变为27个变量的线性方程。忽略这27个变量是如何从18个矩阵元素中形成的，只需将它们视为不可分割的单元。因为现在有27个未知数，艾米丽需要27个已知字母，而不是18个。不太可能，但有可能，尤其是如果她已经截获了多条她知道使用了同一个密钥的消息。例如，假设Emily知道从瑞典发送的每条消息都以单词STOCKHOLM结尾。因为斯德哥尔摩的出现可能开始于3个字母的不同位置，3个不同的信息可以给她27个已知的字母位置。她可以轻松求解27个线性方程组得到27个系数。

从那里很容易解出27个一次二次方程来找到18个矩阵元素——但是为什么要这么麻烦呢？明文字母和密文字母之间的关系都是用27个二次系数来表示的。艾米莉知道这些系数是如何产生的没有任何好处。

希尔-1的情况与希尔-0基本相同。有36个未知数，因此Emily将需要36个已知明文字符。否则求解过程是一样的。Hill-2和Hill-3没有可比的过程。这些最好作为三元模型替换密码来解决。

通过在每一边使用不同大小的矩阵，并在每一边不同地对齐矩阵，您可以从双边矩阵乘法中获得更大的优势。这里有两个这些技术的例子。在第一个示例中，左侧乘法是3×3矩阵，而右侧乘法是4×4矩阵。由于3×3矩阵与4×4矩阵对接，如图所示，我们称之为*对接配置* 。

![15-unnumb-2](Images/15-unnumb-2.png)

这给了你12个字符的有效块大小。因为每个右侧的4×4矩阵跨越两个左侧的3×3矩阵，所以每个密文字符依赖于6个明文字符，而不是4个。利用这种配置，产生每个密文字符只需要7次乘法，所以这种方法非常快。当混合字母是秘密的，但是矩阵是已知的时，平头密码 被评定为6。如果混合字母和矩阵都是秘密的，则它被评定为8。如果矩阵是6×6和7×7或更大，则等级增加到10。当然，不管桑德拉使用的矩阵大小应该是互质的。

*砖墙* 是另一种推荐的双面矩阵乘法的配置。这里的矩阵都是同样的大小，但是它们偏移了一半的宽度，就像墙上的砖块一样。下图说明了该方法。

![15-unnumb-3](Images/15-unnumb-3.png)

注意矩阵的边界从不对齐。这种配置没有块结构，换句话说，你可以说整个消息是一个块。由于每个4×4右侧矩阵跨越两个左侧4×4矩阵，所以每个密文字母依赖于8个明文字母。这对于高安全性的工作来说已经足够了。

如果你实际上对第一个和最后一个块使用2×2矩阵，这将使那些块变得脆弱和易受攻击。它还要求您拥有1×1和3×3矩阵来处理不均匀的消息长度。最好通篇使用4×4矩阵。接下来的两个图显示了如何为长度为13的消息实现这一点。第一张图显示了左侧矩阵的位置，最后一个4×4矩阵与消息的右端齐平。

![15-unnumb-4](Images/15-unnumb-4.png)

下图显示了右侧矩阵的位置，偏移了2个字符。第一个和最后一个4×4右侧矩阵与消息的结尾齐平。

![15-unnumb-5](Images/15-unnumb-5.png)

这种定位最后一个矩阵的方法使最后一个左侧矩阵和最后一个右侧矩阵对齐。这可以通过绕到消息的开头来避免，就像这样。

![15-unnumb-6](Images/15-unnumb-6.png)

当你在左侧矩阵乘法之前有一个混合密钥的简单替换，在右侧矩阵乘法之后有另一个，并且你使用大小为6×6或更大的秘密矩阵时，砖墙密码 被评定为十个。

由于对矩阵求逆需要花费一些努力，所以最好对左右乘法都使用固定矩阵。使用固定矩阵会削弱密码，但您可以通过在两个矩阵乘法步骤之间添加第三个简单的替换来进行补偿。矩阵可以是任何偶数大小，6×6或更大。与希尔密码相比，我们称之为*珠穆朗玛密码* 。珠峰密码T5被评为十级。

## 15.5大整数乘法

大整数乘法在一个重要的意义上类似于矩阵乘法:在矩阵乘法中，乘积的每个元素是两个元素乘积的和，每个元素来自一个矩阵。在大整数乘法中，乘积的每个数字是两个数字乘积的和，每个大整数一个数字。无论如何，这是我把这个主题放在矩阵章节的基本原理。

一个128位的块可以被看作是16个字节，或者是一个128位整数的16位256进制数字。如果您将两个这样的基数为256的整数相乘，则需要256个乘积和256个加法(包括进位)。如果您使用的语言允许您将两个32位无符号整数相乘得到一个64位无符号乘积，那么速度会快很多。那么你只需要16次乘法和16次加法。如果语言允许64位整数与128位乘积相乘，那就更简单了。

非常大的数有更快的乘法方法，比如Karatsuba 和Toom-Cook ，但是这些方法对128位甚至256位数乘法的好处太小，不值得在这里使用，所以我不打算讨论大整数乘法的机制。一些计算机语言自动处理机制，所以用户永远不需要参与。

也就是说，考虑一个密码， *Mult128* ，其中消息以128位的块获取，并且每个块乘以一个秘密的128位整数M模2 <sup class="fm-superscript">128</sup> 。换句话说，只使用256位乘积的低半阶，丢弃高半阶。这意味着乘法中的一些中间乘积不需要计算，因为它们只对乘积的高阶端有贡献。

丽娃可以通过将密文乘以M模2 <sup class="fm-superscript">128</sup> 的乘法逆运算M’来读取消息。只要M是奇数，这个逆就存在。让我们看看如何找到一个乘法逆。

### 15.5.1乘除同余

我在这本书的开头承诺，如果需要的话，我会提供所有必要的数学知识。这是其中的一部分。计算乘法逆元的方法包括乘法线性同余。在我展示如何做到这一点之前，让我们看一个例子，看看为什么这是一个问题。(我在3.6节用了这个例子的一部分。在继续之前，您可能希望重读该部分。)

不是所有的同余都有相同的强度。有些同余是强的，并且有唯一的解。有些同余是弱，有多种解法。一致性越强，它给出的信息就越多。考虑这些一致性，从最强到最弱排列如下:

![15-unnumb-7](Images/15-unnumb-7.png)

出现这种差异的原因是，除了第一个同余式ax≡b (mod n)之外，所有同余式中的参数a、b和n都有一个公因数。在10x≡8 (mod 12)中，参数10，8，12有公因式2，同余式有2个解。在9x≡3 (mod 12)中，参数9，3，12有公因式3，同余式有3个解。诸如此类。公因子越大，解越多，同余越弱。

当a，b，n有一个公约数d时，可以把同余除以d，例如9x≡3 (mod 12)的公因数为3。除以3得到3x≡1(模4)。你可以通过视觉解决这个问题。解是x≡3 (mod 4)。因为3×3 = 9≡1 (mod 4)，所以这是正确的。把这个结果平移回(mod 12)，第一个解是3 (mod 12)，你把12/3 = 4相加，然后再加上4，得到另外两个解，即7 (mod 12)和11 (mod 12)。

概括一下，如果a、b和n有一个公约数d，那么就有d个不同的解。第一个解是a/d≡b/d (mod n/d)的解，其他解间隔n/d。

让我们看看另外两种情况。再次假设ax≡b (mod n)且a和n有一个不除b的公约数，例如3x≡7 (mod 30)。那么同余无解。而是假设a和b有一个不除n的公约数d，那么你可以把a和b除以d，比如如果10x≡25 (mod 37)，那么2x≡5 (mod 37)。这可以在你的头脑中通过将37加5，得到2x≡42 (mod 37)来解决。除以2得到x≡21 (mod 37)。

就像你可以把a和b除以一个常数一样，你也可以把a和b乘以一个常数m，那个m一定不能和n有公因数，换句话说，m必须是模n可逆的，否则你会让同余变弱，丢失信息。比如，假设给你9x≡3 (mod 12)。这是一个有3个解的弱同余。如果把a和b乘以2，同余就变成18x≡6 (mod 12)，相当于6x≡6 (mod 12)，有6个解。弱同余变得更弱了。

你也可以加减同余，同余有相同的模数。假设ax≡b (mod n)，cx≡d (mod n)。这些可以相加得到(a+c)x≡b+d (mod n)，或者相减得到(a-c)x≡b-d (mod n)。这可以用来加强一组弱同余。比如假设你有9x≡3 (mod 12)和8x≡4 (mod 12)。第一个同余式有3个解，第二个有4个解。如果将它们相加，得到17x≡7 (mod 12)，这就减少到5x≡7 (mod 12)，这就有了唯一解x≡11 (mod 12)。更聪明的是，如果你减去两个同余，那就得到(9-8)x≡(3-4) (mod 12)，直接得到x≡11 (mod 12)。

## *15.6解一次同余

现在 你知道如何安全地操作同余而不失力，我们可以着手解决如何求解一个线性同余ax≡b (mod m)的问题，其中a，b和m是给定的常数，x是我们试图寻找的未知值。在b = 1的特殊情况下，x是a模m的乘法逆运算，大多数教科书只提到一种叫做*扩展欧几里德算法* 的技术。(欧几里得算法通常被认为是雅典的西厄蒂特斯发明的，他生活在欧几里得算法出现前大约一个世纪。那是一个非常好的方法。当模数很小时，或者当模数有几个不同的小质因数时，这可能是正确的方法。当因子分解未知且存在小因子的可能性时，这绝对是正确的方法。

然而，在密码学中，只有两种常见的情况需要我们计算乘法逆运算，当模数是质数时，以及当模数是2的幂时。本节将描述一种更简单、更直接的方法。

### 15.6.1减少同余

求解一个同余ax≡b (mod m)的基本方法是反复降低x的系数，最简单的方法是 *ResM* 。它将同余式乘以一个整数n，这个整数n刚好足以使x的系数至少与模数一样大。即a(n-1) < m ≤ an。您可以通过除以m/a并向上舍入来确定n的值，因此2.0000保持为2，但2.0001将变为3。当系数以m为模减小时，结果是一个更小的系数。

让我们从一个简单的ResM例子开始，以便获得基本的想法，并且当事情开始变得复杂时，便于后面的讨论。取同余38x≡55 (mod 101)。我们知道101/38 = 2.658，所以我们将同余式乘以3，然后以101为模进行约简，如下所示:

![15-unnumb-8](Images/15-unnumb-8.png)

注意，x的系数从38减少到了13。这个可以再减。我们有101/13 = 7.769，所以我们把同余乘以8，就像这样:

![15-unnumb-9](Images/15-unnumb-9.png)

我们就快到了。101/3 = 33.667，所以将最后一个同余乘以34，x系数就减少到1:

![15-unnumb-10](Images/15-unnumb-10.png)

我们可以通过把x = 36插回原来的同余式38x≡55 (mod 101)来检验这个结果。把x换成36，得到38×36≡55 (mod 101)，也就是1368≡55 (mod 101)，这是真的。正确答案是x≡36 (mod 101)。

### 15.6.2对半规则

让我们来看一下 的小改进。我们可以称之为*对半法则*。大约一半的时候，m/a的小数部分小于1/2，一半的时候大于1/2。设q = m/a .那么一半时间qa更接近m，一半时间(q+1)a更接近m。

一个数字例子可能有助于使这一点更清楚。设m是101，设a是40。那么q = 101/40 = 2.525。分数. 525大于1/2。如果取40×2，结果是80，比101少21。如果取40×3，结果是120，比101多19。所以40×3比40×2更接近101。因此，n = 3是最佳乘数。

相反，假设a是41。那么m/a = 101/41 = 2.463。这一次，分数. 463小于1/2。如果取41×2，结果是82，比101少19。如果取41×3，结果是123，比101多22。所以41×2比41×3更接近101。因此，n = 2是最佳乘数。

概括一下，当q = m/a的小数部分小于1/2时，如果我们将q向下舍入，na更接近m，但当m/a的小数部分大于1/2时，如果我们将q向上舍入，na更接近m。使用下限和上限符号(第13.3节)，如果frac(q) < 1/2，选择n = ⌊ q ⌋，但是如果frac(q) > 1/2，选择n = ⌈ q ⌉ 。这听起来很容易，但有一个复杂的问题。当n = ⌈ q ⌉ 时，na大于m，所以你通过减去m的倍数来减少同余，就像我们在本节开始时所做的那样。当n = ⌊ q ⌋ 时，na小于m，所以你通过从m的倍数中减去它来减少同余

从...开始

![15-unnumb-33](Images/15-unnumb-33.png)

由于101/41 = 2.463，将同余乘以2，给出

![15-unnumb-34](Images/15-unnumb-34.png)

从101的倍数中减去这个数，即

![15-unnumb-35](Images/15-unnumb-35.png)

由于101-82 = 19和202-180 = 22，你得到

![15-unnumb-36](Images/15-unnumb-36.png)

为了说明这带来了多大的改进，让我们并排解决一个有和没有对半规则的同余问题。

![15-unnumb-11](Images/15-unnumb-11.png)

如果没有对半原则，还原需要8个步骤。根据对半原则，减少需要4个步骤。该比率因不同的系数和模数而异，但8:4是合理的典型值。使用对半法则的ResM可以称为 *ResMH* 。

### 梯子

当 整数很大的时候，这个还是有点慢，因为我们是在做大数的乘法和除法。*阶梯技术*可以用来避免这种情况。它对每个步骤使用两个同余。阶梯技术不是将x的系数乘以不断增加的数来使其值接近模数，而是将每个同余中的系数乘以一个小的数来使其值接近前一个系数。这需要一个额外的同余来启动这个过程。为此，我们使用同余式mx≡m (mod m)，它相当于0x≡0 (mod m)。

让我们来看一个使用更大数字的例子:

![15-unnumb-12](Images/15-unnumb-12.png)

由于28338689/6114257约为4.635，乘以5再减去得到

![15-unnumb-13](Images/15-unnumb-13.png)

这里6114257/2232596大约是2.739，所以乘以3再减去得到

![15-unnumb-14](Images/15-unnumb-14.png)

继续这种方式得到，先后，

![15-unnumb-15](Images/15-unnumb-15.png)

这些例子中的每一个都使用了质数模。当模数为复合模数时，情况变得更加复杂。我不会在这里涵盖所有这些复杂性。对于密码学来说，最重要的情况是模数是2的幂，比如2 <sup class="fm-superscript">32</sup> 或2 <sup class="fm-superscript">128</sup> 。在这种情况下，您在每个阶段选择的乘数必须是奇数。因此，不是将乘数舍入到最接近的整数，而是总是舍入到奇数。例如，3.14将被舍入到3，3.99也将被舍入到3。使用阶梯的ResMH可称为 *ResMHL* 。

### 15.6.4连分数

一旦你有了两个或更多的线性同余，你可以通过使用一种叫做*连分数*的技术来更快地减少x的系数。连分数是一种用分数近似十进制数的方法。考虑十进制数R = .13579。r介于1/7和1/8之间。更准确地说，R约为1/7.3643。这个也可以写成1/7+.3643。请注意，加号+是分数的分母。这表明加法是在分母中完成的，而不是将两个分数1/7+3643相加。

分数. 3643可以近似为1/2.745，或者1/2+.745，那么R现在就是1/7+1/2+.745。这里. 745非常接近3/4，所以近似值可以是1/7+1/2+3/4。要把它还原成一个普通的分数，只需倒推:

![15-unnumb-15-equation-15-17](Images/15-unnumb-15-equation-15-17.png)

小数11/81是. 13580，与. 13579只相差. 00001。如你所见，这种方法给出了很好的近似值。

让我们再次尝试第15.4.3节中的例子，

6114257 x≥90926(修改28338689)。

对于第二个同余，我们使用0 = 0的技巧，

28338689 x≥28338689(修改28338689)。

这里6114257/28338689是

![15-unnumb-15-equation-15-18](Images/15-unnumb-15-equation-15-18.png)
T2】

获得近似的一个好的经验法则是在一个大分母之前停止，在这个例子中是24。截断24之前的连分数，得到

![15-unnumb-15-equation-15-19](Images/15-unnumb-15-equation-15-19.png)
T2】

算出来是241/1117。

将6114257的同余乘以1117，将28338689的同余乘以241，然后相减得到

![15-unnumb-16](Images/15-unnumb-16.png)

这将x的系数从6114257降低到1020，系数为5994。所以连分式法比其他方法用的步骤少得多。但是，使用起来很棘手，因为上一步的系数可能比下一步的系数大得多，例如6829625069 vs 1020 。 你可以通过在连分数步和半步之间交替来平衡系数。 ******

## 15.7大整数密码

有许多密码可以用大整数乘法来构造。第15.3节描述了Mult128 密码，其中消息采用128位块。每个块被视为一个128位整数，并乘以一个秘密的128位整数M模2 <sup class="fm-superscript">128</sup> 。为了获得良好的混合，乘法器的每个字节都应该非零。这仍然是弱的，因为每个密文块的低阶n位仅取决于明文的低阶n位和密钥m的低阶n位，这使得低阶字节的加密成为简单的替换。在乘法前后进行简单的替换并不能解决这个问题。同样，低阶2字节进行二元模型替换，低阶3字节进行三元模型替换。Mult128 被评为三级。

解决低位字节问题的一种超快速方法是将高位字节与低位字节合并，例如通过使用 **xors** 或 **adds** 合并函数。这将把评级提高到五级。更好的解决方案是使用**异或**或**相加**将高位8字节与低位8字节合并。这将评级提升至7级。这里有一个例子。

![15-unnumb-17](Images/15-unnumb-17.png)

增强密码的一种方法是置换16个字节，然而，利用足够的密文，Emily可以检测出哪个字节位置具有最小的可变性，因此必须是置换的低阶字节。*置换Mult128* 被评为四级。

一个更强的方法是相乘、置换、再相乘。置换需要将弱低阶字节移入块的高阶半部分。合适的排列是(1)颠倒字节的顺序，(2)交换块的低阶和高阶部分，或者(3)以相反的顺序交错低阶和高阶字节。如果使用十六进制数字0到F从高到低对字节进行编号，那么这3种排列可以表示为

![15-unnumb-18](Images/15-unnumb-18.png)

如果您的编程语言允许您将块既作为32位字又作为单字节来操作，那么颠倒4个字的顺序可能会更快，从而导致这种排列:

![15-unnumb-19](Images/15-unnumb-19.png)

这个密码被命名为 *MPM128* ，等级为7。

当你在这个过程中加入替换步骤时，力量就会激增。设S <sub class="fm-subscript">1</sub> ，S <sub class="fm-subscript">2</sub> ，S <sub class="fm-subscript">3</sub> 和S <sub class="fm-subscript">4</sub> 为4个独立的混合密钥替换，设P为固定排列5BF4AE39D28C1706，设M <sub class="fm-subscript">1</sub> ，M <sub class="fm-subscript">2</sub> 和M <sub class="fm-subscript">3</sub> 为3个秘密128位整数相乘。然后暗号S<sub class="fm-subscript">1</sub>M<sub class="fm-subscript">1</sub>PS<sub class="fm-subscript">2</sub>M<sub class="fm-subscript">2</sub>S<sub class="fm-subscript">3</sub>PM<sub class="fm-subscript">3</sub>S<sub class="fm-subscript">4</sub>，称为*老虎* ， 被评为十级。

## 15.8小整数乘法

Mult128 的缩小版可以使用普通的无符号32位乘法来完成。128位块被视为四个32位整数。这些整数中的每一个都乘以一个秘密的32位整数模2 <sup class="fm-superscript">32</sup> 。这4个乘数必须是奇数，以便以后解密。这就产生了一个32位的密码。为了得到128位密码，4个独立的4字节乘积可以被视为一个16字节块，并使用这个固定的16字节密钥转置进行混合(第7.6节):

![15-unnumb-20](Images/15-unnumb-20.png)

转置之后是第二个乘法步骤，再次将16字节块视为四个32位整数。您可以使用相同的乘数或新的乘数。这之后是第二次转置，以及另一轮乘法，因此有3轮乘法和两轮转置。这个密码被称为Mult32 、和，等级为7。它比任何Mult128密码变体都要快得多。

让我们把一个128位块的16个字节看作一个4×4的字节矩阵。这个矩阵的任何一行中的4个字节可以被视为一个32位整数。通常，整数的4个字节从左到右取，最左边的字节是高位字节。然而，它们也可以按相反的顺序取值，最左边的字节是低位字节。考虑十六进制的数01020304。如果我们以正常方式将这个乘以十六进制数01010101模2 <sup class="fm-superscript">32</sup> ，结果就是十六进制的0A090704。如果我们以相反的顺序将04030201乘以十六进制数01010101模2 <sup class="fm-superscript">32</sup> ，结果就是十六进制的0A060301。

同理，我们可以把任意一列中的4个字节当作一个32位的整数，无论是从上到下的顺序还是从下到上的顺序。称两个水平方向为东和西，称两个垂直方向为北和南。如果我们按照东、北、西、南的顺序将行和列乘以奇数32位整数模2 <sup class="fm-superscript">32</sup> ，这提供了彻底的混合。这需要16个独立的32位乘法器。总密钥大小是16×31 = 496位，而不是16×32 = 512，因为乘数必须是奇数。这个密码可以叫做*罗盘* ，等级为八级。

要将评分提高到10分，请添加一轮或多轮替换，例如，东、北、替换、西、南。更好的是，添加多个替代，如东，替代，北，西，替代，南。把这种*叫做* 。即使你使用固定的替代，如果它们是高度非线性的，CompassS被评定为10。

使用小整数乘法的另一种方法是做*循环乘法* 。设块中每32位行的字节从左到右编号为1，2，3，4，即从高位字节到低位字节。将这个乘以一个奇数模2 <sup class="fm-superscript">32</sup> 。将字节1移动到低位末端，因此顺序现在是2、3、4、1。再乘以一个奇数模2 <sup class="fm-superscript">32</sup> 。重复这两次以上，所以每个字节占据每个位置一次。也就是说，字节的顺序是1234、2341、3412，最后是4123。对于总共16次乘法和12次循环移位，应该对4×4字节矩阵的4行中的每一行都这样做。

然后对列进行同样的操作。总共有32次乘法和24次循环移位。这个循环乘法密码被定为八级。它可以有多达32个不同的32位密钥乘法器。

本节中的方法可以以多种方式与第15.4节中的方法相结合。这里仅举一个例子，我称之为 *Mat36* 。将消息分成36个字符的块，这些字符被视为9个32位整数。这些形成一个3×3的整数模2矩阵 <sup class="fm-superscript">32</sup> 。这个矩阵将乘以一个秘密的3×3整数可逆矩阵。如果您简单地在右边乘以另一个3×3矩阵，9个整数的低位字节将被弱加密。相反，将整个36字节块向左循环16位，然后将右边的块乘以第二个秘密的3×3可逆整数矩阵。Mat36被评为八级。

## 15.9乘法模P

当以2 <sup class="fm-superscript">n</sup> 为模进行乘法运算时，低阶字节被弱加密，我们需要通过跳圈来修复这个弱点。当以素数p为模进行乘法运算时，不会出现这个问题。对于大型乘法器，乘积的每一位都取决于明文的每一位。还有一个不同的问题。让我们假设你已经选择了一个素数P < 2 <sup class="fm-superscript">n</sup> 和一个乘数M，其中1 < M < P。这可以让你安全地将0到P-1的值乘以M模P，因此丽娃可以通过乘以M’来解密这些值，M’是M的倒数

然而，明文值0将保持不变，并且从P到2 <sup class="fm-superscript">n</sup> -1的明文值不能安全地相乘，因为结果将是不明确的。例如，3和P+3乘以M模P会得到相同的结果，因为3M≡PM+3M(mod P ),所以丽娃无法判断消息是3还是P+3。这意味着从P到2 <sup class="fm-superscript">n</sup> -1的值必须保持不变。为此，将函数modp定义如下:

![15-unnumb-21](Images/15-unnumb-21.png)

这个问题的一个解决方案是Sandra对明文进行异或运算。这暗示了一族*模P密码*。让我们确定n = 64的值，意味着8字节的块大小，质数模数P = 2<sup class="fm-superscript">64</sup>-59 = 18446744073709551557，乘数M = 39958679596607489，也是质数。

桑德拉通过选择一个秘密的64位常数C <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub> 作为密钥，计算x = modp(c<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub>t5】⊕b)+c<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub>，对一个64位明文块b进行加密。这是家族中的第一个密码。称之为 *PMod1* 。它被评定为五级。家族中的第二个密码是pmod 2*，它是PMod1的两次迭代，使用第二个64位常量C <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2</sub> :*

 *![15-unnumb-22](Images/15-unnumb-22.png)

PMod2被评为七级。家族中的第三个密码， *PMod3* ，有3次迭代，被评定为9:

![15-unnumb-23](Images/15-unnumb-23.png)

第四个成员， *PMod4* ，额定十。它的总密钥大小为256位，是块大小的4倍:

![15-unnumb-24](Images/15-unnumb-24.png)

每次加法都是以2 <sup class="fm-superscript">n</sup> 为模，而不是以p为模

四种PModX密码都非常快，因为大多数编程语言都直接支持64位加法、乘法和模除。在某些计算机中，它们是单一的机器指令。这使得PModX密码作为一个单元处理4或8个字节，而不是像DES那样分别处理每个4位块。这类密码非常适合软件加密。PMod2比DES更安全，因为它的密钥更大，PMod4比3DES更安全。

有第二种乘法模P的方法可以消除不变的值。这个想法是把从0到2 <sup class="fm-superscript">64</sup> -1的整数范围分成两个独立的范围，每个范围有不同的质数模和不同的乘数。选择两个素数P和Q，使得P+Q = 2 <sup class="fm-superscript">64</sup> +2。大约有1016个这样的对，所以很容易找到，例如P = 9228410438352162389和Q = 9218333635357389229，以及两个大乘法器M < P和N < Q。棘手的是，你必须移动每个范围，以便你只乘以范围1到P-1或1到Q-1中的数字。通过重新定义modp函数可以做到这一点。

![15-unnumb-25](Images/15-unnumb-25.png)

有了这个重新定义的modp函数，PMod1到PMod4密码的工作方式和以前一样，并且具有相同的等级。该图显示了范围0到2 <sup class="fm-superscript">64</sup> -1是如何划分的。

![15-unnumb-26](Images/15-unnumb-26.png)

## 15.10基数的变更

改变数基数与乘以一个大整数密切相关。当数字非常大时，改变数字基数是一个缓慢的操作，所以最好的策略是将消息分成块，并分别转换每个块。更改基数会模糊消息字节之间的间隔。

有两种方法可以将数字从一种基数转换成另一种基数。您可以从低端工作，也可以从高端工作。许多人在学校里学习这些技巧，但是随着时间的推移，他们经常忘记这些技巧。为了唤起大家的记忆，这里展示了这两种方法。我们将使用低端技术将数字1A87从基数11转换为基数7，然后使用高端方法转换回基数11。

使用低端技术，你反复用新基数除这个数。每个余数都成为转换后的数字的下一位。以下是转换1A87的步骤:

1A87/7是312，余数是4 T2。

312/7是49，余数是5(T2)。

49/7是7加上余数 **4** 。

7/7是 **1** 加上余数 **0** 。

所以11进制的1A87变成7进制的10454。

使用高端技术，你重复地将高端数字乘以旧基数，然后添加下一个数字。以下是转换10454的步骤:

**1** ×7+ **0** 是7。

7×7+ **4** 是49。

49×7+ **5** 是312。

312×7+ **4** 是1A87。

如果你觉得这些数字不太对，请记住7、49、312和1A87都是以11为基数的。

基于不断变化的基数，你可以做出许多简单的密码。例如，16字节块也是以256为基数表示的16位数。将这个数字转换成另一个基数，比如263。现在，您可以转置基数为263的数字，或者执行替换，或者两者都执行。然后你可以把它转换成基数277，做同样的事情。最后，你转换回基数256。这需要一个17字节的数字来保存结果。您可以使用256到362之间的任何基数。请记住，如果任何结果有一个前导数字0，该数字是必需的，以便丽娃可以解密密文。

如果每一个连续的基数比前一个大一点，那么每一阶段都需要相同的位数。只有在最后一步将数字转换回基数256时，位数才会增加。没有理由要求碱基是质数。

这里有一个基于基数变化的分组密码的概念。从一个秘密的混合键控简单替换开始。S操作字节，即从0到255的整数。通过保持任何大于255的数字不变，s可以扩展到大于256的基数。这消除了为每个可能的碱基建立单独的替换表的需要。选择3个数基数B <sub class="fm-subscript">1</sub> ，B <sub class="fm-subscript">2</sub> ，B <sub class="fm-subscript">3</sub> 满足256<B<sub class="fm-subscript">1</sub>T23】B<sub class="fm-subscript">2</sub>T24】B<sub class="fm-subscript">3</sub>T25】363。您还需要在16个元素上进行3次键控移调T <sub class="fm-subscript">1</sub> ，T <sub class="fm-subscript">2</sub> 和T <sub class="fm-subscript">3</sub> 。这些元素是整数，可以大到B <sub class="fm-subscript">3</sub> -1，所以它们每个都需要超过1个字节。

分组密码 *3Base* 由以下步骤组成:(1)替换S. (2)转换为base B <sub class="fm-subscript">1</sub> 。(3)替换S. (4)转置T <sub class="fm-subscript">1</sub> 。(5)转换到基数B <sub class="fm-subscript">2</sub> 。(6)替换S. (7)转置T <sub class="fm-subscript">2</sub> 。(8)转换到底座B <sub class="fm-subscript">3</sub> 。(9)替换S. (10)转置T <sub class="fm-subscript">3</sub> 。(11)换算成基数256。(12)替换s。直到步骤11，密码块由16个元素组成。步骤12将块扩展到17字节。密码3Base被定级为10。

## *15.11环

一个 一个*环*是整数的抽象版本。也就是说，一个环是一组元素，它们可以像整数的加法和乘法一样进行加法和乘法运算。你已经熟悉了几个环:整数、有理数、实数、整数模某个定数，也许还有复数和代数数。一些不太熟悉的环是多项式，其系数是环的成员，矩阵的元素是环的元素，a +b√13形式的数，a +b ∛ 7+c ∛ 49形式的数，以及a +b√2+c√3+d√6形式的数，其中a、b、c和d可以是整数、有理数或模某个固定整数的整数。

在我们讨论如何在密码学中使用环之前，让我们先列出环的形式规则。环加用+号a+b表示，环乘用并置ab表示。

*   对于所有的环元素a和b，a +b和ab都是环的元素。(关闭)

*   对于所有的环元素a、b、c，a +(b+c) = (a +b)+c .(加法的结合律)

*   对于所有环元素a和b，a +b = b +a。(加法的交换法则)

*   存在一个环元素0使得0+a = a +0 = a对于所有的环元素a .(加性恒等式)

*   对于每个环元素a，都有一个元素-a使得a +(-a) = (-a)+a = 0。(加法逆)

*   对于所有的环元素a、b和c，a(bc) = (ab)c(乘法结合律)

*   对于所有的环元素a，b，c，a(b +c) = ab +ac，(a +b)c = ac +bc。(分配规则)

*   对于每个元素a，有一个环元素1使得1a = a1 = a。(乘法恒等式)

加加法逆时通常会去掉括号，所以(-a)+b变成-a +b，a +(-b)变成a-b。

注意，环乘法不一定是可交换的。如果环的乘法是可换的，那么这个环叫做*可换的* 。前面所有的例子都是交换环。现在，让我们假设所有讨论中的环都是可交换的。如果一个环元素a有一个乘法逆a’，使得aa’= 1，则称a为*可逆*。在处理有限环时，建议尝试将所有可能的元素对相乘，以确定哪些元素是可逆的，并保留一个逆矩阵表以供快速参考。

使用环算术进行加密的一个简单方法是将11.8节的波纹密码与13.14.1节的滞后线性加法相结合。我们来选择戒指 ***R13*** ，其元素形式为*a*+*b*√13，其中a和b为十六进制数字，即整数模16。两个十六进制数字a和b组成一个字节，代表一个字符。比如字母X在 ASCII码中表示为十六进制58，对应***R13***环元素 5+8√13 。

两个 ***R13*** 环元素*a*+*b*√13和 *c* + *d* √13 增加为(*a*+*c*)+(*b*+*d例如:如果 *x* = 2+3√13 和 *y* = 4+5√13 ，那么*x*+*y*就是 6+8√13 和 *xy** 就是 11+6√

对于组合的纹波+滞后线性加法密码，可以称为*滞后纹波* ，你用ax<sub class="fm-subscript">n</sub>+bx<sub class="fm-subscript">n-I</sub>+CX<sub class="fm-subscript">n-j</sub>代替x <sub class="fm-subscript">n</sub> ，其中系数a、b和c是环的元素，在这种情况下是***R13***明文可以分成16字节的块，但是对于短消息，加密可以应用于整个消息。让我们假设后者。那么加密将会是

x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>= ax<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">【n4t】+bx<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>+CX<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-5</sub>表示n = 1，2，3，-我...。，l .</sub>

这里a是 ***R13*** 的可逆元素，b和c是 ***R13*** 的任意元素，L是消息的长度。运算是在环中进行的。您可能认为这是第11.8节中的 **madd** 组合功能的变体。通常的绕回将用于加密前几个字节。

对于使用已知固定滞后的单程，滞后波动被评定为2，因为可能的系数组合只有256 <sup class="fm-superscript">3</sup> 。在滞后纹波阶段之前和之后进行简单的替换，额定值增加到5。使用3遍，每遍具有不同的系数和不同的滞后，评级为6。

*三重波纹* 在每次波纹传递之前和最后一次波纹传递之后，使用3次传递和一次秘密键控简单替换。每次传递都有不同的秘密系数和滞后。或者，您可以在每次传递和回绕时从消息中的不同位置开始波动。三重波纹被评为 十级。

## 15.12环上的矩阵

在 第15.1节和第15.2节中，我们研究了希尔密码，该密码将消息的每个块视为一个整数向量，并将该向量乘以一个以26或256为模的整数矩阵。以26或256为模的整数没什么神奇的。您可以使用任何环的元素来表示消息的字符。如果字符比环形元素多，可以使用成对或三元组的环形元素，就像在波利比乌斯正方形(第9.1节)中使用1到5的整数对来表示25个字母的字母表一样。

假设你在 ***R13*** 上使用了一个矩阵，其元素具有形式*a*+*b*√13的环。如果您将明文块视为32个十六进制数字而不是16个字节的向量，并写出矩阵乘积的每个数字的表达式，您将看到密文中的每个十六进制数字都是明文数字的线性组合。所以在***R13***环上使用16×16的矩阵相当于在十六进制数字上使用32×32的矩阵，即整数模16。因此，这种密码仍然容易受到已知明文攻击。这种攻击至少需要256字节的明文。大概16×17 = 272字节就足够了。

你，发送者，可以通过在矩阵乘法之前和之后使用一个带密钥的简单替换来轻易地击败这样的攻击。或者，你可以构建你自己的戒指，一个除了你的合法通信者之外任何人都不知道的戒指。只要你能保守你的戒指的秘密，没人能对你的矩阵 密码发动任何攻击。

## 15.13构建一个环

一个N元的 环，称为*阶* N的环，用两个N×N的表，它的加法表和它的乘法表来表示。构建环可以分阶段完成。让我们构建一个由8个元素组成的环作为演示。首先构建加法表。从一开始你就知道环必须有两个元素，0是加性单位，1是乘法单位。对于所有的a，和0+a和a+0是已知的。这给了我们加法表的顶行和左列。

![15-unnumb-27](Images/15-unnumb-27.png)

接下来，从第二排开始。策略是取值尚未赋值的第一个总和，给该总和赋值，然后使用关联规则对其他总和进行所有可能的推断。假设你想要1+1 = 2，2+1 = 3，3+1 = 4，4+1 = 0。使用关联规则，您现在可以填充表格的左上部分。比如你可以确定2+2，因为2+2 = (1+1)+2 = 1+(1+2) = 1+3 = 4。

![15-unnumb-28](Images/15-unnumb-28.png)

由于4+1 = 0，因此1的加逆为4，4的加逆为1。同样，2是3的加法逆，3是2的加法逆。那么，我们应该给5+1赋什么值呢？它不能是0，因为4和5不能都是1的加逆。它不能是1，因为那样的话5就是0了。它不可能是2，因为5+1 = 1+1意味着5 = 1。同样，5+1不可能是3或4。它也不可能是5，因为5+5 = 5意味着5 = 0。剩下5+1 = 6或5+1 = 7。这些是等价的，所以假设5+1 = 6。这迫使6+1 = 7和7+1 = 5。也就是说5+1+1+1 = 5。这使得1+1+1 = 0。既然我们已经知道1+1+1 = 3，那就意味着3 = 0。不可能。这是个死胡同。设置4+1 = 0不起作用。

哪里出了问题？循环1+1+1+1+1 = 0有5项。N阶环中任何这样的循环的长度必须能整除N。因为5不能整除8，所以不可能完成加法表。这样你就有三个选择，让周期长度变成2，4或8。如果你选择循环长度为8，那么这个环就是以8为模的整数。如果选择周期长度2，则加法与异或相同。因为目标是开发一个新的环，所以周期长度为4。加法表必须是

![15-unnumb-29](Images/15-unnumb-29.png)

现在可以用分配法则算出乘法表。比如2×2 = 2×(1+1) = 2+2 = 0。

![15-unnumb-30](Images/15-unnumb-30.png)

姑且称这个戒指为**。注意，1和3是环***【R8***中仅有的具有乘法逆运算的元素，并且每一个都是它自己的逆运算。**

 **有两个环值得特别一提，高斯整数和四元数。

### 15.13.1高斯整数

*高斯整数*是a+bi形式的数，其中a和b是整数，I是虚数√-1。换句话说，高斯整数是实数和虚数都是整数的复数。对于密码用途，a和b可以是模16的整数。高斯数a+bi因此可以用来表示十六进制数ab。例如，字母X，在十六进制 ASCII码中是58，可以用高斯整数5+8i来表示。

高斯 整数相加相乘如下:

![15-unnumb-31](Images/15-unnumb-31.png)

其中加法和乘法以16为模进行，供密码 使用。

### 15.13.2四元数

四元数 是爱尔兰皇家天文学家、都柏林三一学院的爱尔兰数学家威廉·罗恩·汉密尔顿于1843年发明的，用来描述旋转物体的运动。它们是a+bi+cj+dk形式的数，其中a、b、c和d是普通数，I、j和k是抽象单位。四元数的定义关系是I<sup class="fm-superscript">2</sup>= j<sup class="fm-superscript">2</sup>= k<sup class="fm-superscript">2</sup>= ijk =-1。从这个关系式中，您可以推导出这些乘法规则:

![15-unnumb-32](Images/15-unnumb-32.png)

四元数乘法不可交换。四元数通常被用作非交换环的*例子。*

 *四元数在物理学中广泛用于表示球面上的点和固体的旋转。通过让a、b、c和d是模16或模256的整数，它们可以适用于密码用途。这将让每个四元数代表一条消息的2或4个字符。

使用四元数的另一种方法是让系数a、b、c和d是模2的整数 <sup class="fm-superscript">32</sup> 。您可以使用一组混合良好的5位、6位或8位字符代码，这样每个系数可以分别代表6、5或4个字符。因此，整个四元数将代表消息的24、20或16个字符。你可以通过一个秘密的四元数乘法器左乘或右乘M来加密消息四元数M。AMB说，因为四元数乘法是不可交换的，所以左乘和右乘都要强得多。与普通乘法一样，每个分量中的低阶字节是最弱的，因此在第一次乘法后，最好将整个16字节块循环左移16位。相同的字符代码集可用于将产品转换回标准ASCII字符，但使用不同的代码集更有效，最好是不同大小的代码。

让我们称这个方法为 *Qmult* 。Qmult被评为十级。为了破译这个消息，丽娃必须左乘逆四元数A’，右乘逆四元数B’。四元数a+bi+cj+dk的逆由(a-bi-CJ-dk)/(a<sup class="fm-superscript">2</sup>+b<sup class="fm-superscript">2</sup>+c<sup class="fm-superscript">2</sup>+d<sup class="fm-superscript">2</sup>)给出。由于我们是以2 <sup class="fm-superscript">32</sup> 为模运算，所以每当a<sup class="fm-superscript">2</sup>+b<sup class="fm-superscript">2</sup>+c<sup class="fm-superscript">2</sup>+d<sup class="fm-superscript">2</sup>为奇数时，即每当系数中的一个或三个为 奇数时，就会有一个乘法逆。

## 15.14寻找可逆矩阵

到用一个矩阵作希尔式密码，这个矩阵必须是可逆的。可逆矩阵通常很难找到。如果环中可逆元素的个数为I，元素的总数为r，那么该环上的随机n×n矩阵可逆的概率为(i/r) *n* 。对于**环，i/r为2/8 = 1/4。(这与有理数或实数上的矩阵形成鲜明对比，在有理数或实数上，除了0之外的每个元素都有乘法逆，因此几乎每个矩阵都是可逆的。)如果矩阵很小，您通常可以通过随机选择元素，然后尝试最后一个元素的所有可能值，或者最差情况下，最后两个元素，来找到一个可逆矩阵。通过使用最后1或2个元素，您可以将矩阵缩减到最下面的两行，而不必对每个试验进行完全缩减。**

 **我选择不在本书中讨论行列式，因为我不知道它们在密码学中的任何用途，然而，对于熟悉行列式的读者来说，如果矩阵行列式的值是环中的可逆元素，那么矩阵就是可逆的。特别地，整数上的矩阵只有当它的行列式为+1或-1时才是可逆的。

当期望矩阵较大时，*找*一个可逆矩阵可能不可行。相反，你需要*构造*一个可逆矩阵。首先以两种特定形式之一构造一组所需大小的矩阵:三角形和块对角线。以下是四种三角矩阵的4×4个例子。

![15-unnumb-32-equation-15-32](Images/15-unnumb-32-equation-15-32.png)

上三角矩阵只在主对角线(左上到右下)上有非零元素。所有其他条目都为零。下三角矩阵只在主对角线上或主对角线下有非零元素。所有其他条目都为零。上反三角矩阵只有在反对角线(左下到右上)上有非零元素。所有其他条目都为零。较低的反三角矩阵只有在反对角线上或下面有非零元素。所有其他条目都为零。

如果对角线上的所有元素都是可逆的，那么三角矩阵就是可逆的。一个反三角矩阵是可逆的，如果反对角线上的所有元素都是可逆的。利用15.1.1节的技巧，可以很容易地求出这些矩阵的逆。对于上三角和下反三角矩阵，15.1.1节的化简过程应从右向左进行。

一个一般的可逆矩阵可以通过将这些三角形相乘来构造。这件事必须谨慎从事。两个上三角矩阵的乘积仍将是上三角，两个下三角矩阵的乘积仍将是下三角。反三角矩阵没有这个性质。一个合理的方法是为这四种三角形分别构建一个矩阵，然后形成它们的乘积。如果三角矩阵是A，B，C和D，并且它们的逆是A’，B’，C’和D’，那么乘积ABCD的逆是D’C’B’A’。

除了三角矩阵，块对角矩阵也可以用来构造可逆矩阵。这是一个5×5块对角矩阵的例子。该矩阵可以被称为类型2，3，因为它由沿着5×5矩阵的对角线排列的2×2矩阵和3×3矩阵组成。

![15-unnumb-32-equation-15-33](Images/15-unnumb-32-equation-15-33.png)

两个同类型的块对角矩阵相乘，结果是同类型的块对角矩阵。

使用块对角矩阵的好处是你可以分别找到每个块的逆矩阵。如果你沿着对角线把这些逆矩阵串起来，结果就是整个矩阵的逆矩阵。找一个16×16的可逆矩阵可能不可行，但是找四个4×4的可逆矩阵也不是太难。通过乘以其他类型的块对角矩阵，或者乘以一些可逆的三角矩阵，可以将可逆的块对角矩阵扩展为全矩阵。

全力以赴。尽可能使用最大的块来构造你的可逆块对角矩阵，并使用4个三角矩阵，每种一个。你最终的可逆矩阵是所有五个矩阵的乘积。 *************