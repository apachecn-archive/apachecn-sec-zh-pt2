# 3个消息认证码

本章涵盖了

*   消息认证码(MAC)
*   MAC的安全属性和陷阱
*   广泛采用的MAC标准

将一个散列函数与一个秘密密钥混合，你就获得了一种叫做*消息认证码* (MAC)的东西，这是一种保护数据完整性的密码原语。添加密钥是任何类型安全性的基础:没有密钥就没有保密性，也就没有身份验证。虽然哈希函数可以为任意数据提供身份验证或完整性，但这要归功于一个额外的不可篡改的可信通道。在这一章中，你将看到如何使用MAC来创建这样一个可信的通道，以及它还能做什么。

注意对于本章，你需要阅读第二章关于散列函数的内容。

## 3.1无状态cookies，一个激励MAC的例子

让我们设想以下场景:你是一个网页。你很聪明，充满色彩，最重要的是，你为服务于一个忠诚的用户群体而自豪。要与您互动，访问者必须首先通过向您发送他们的凭据来登录，然后您必须验证这些凭据。如果凭证与用户第一次注册时使用的相匹配，那么您已经成功地*认证了*用户。

当然，网络浏览体验不仅仅由一个请求组成，而是由许多请求组成。为了避免用户在每次请求时都要重新验证身份，您可以让他们的浏览器存储用户凭据，并在每次请求中自动重新发送它们。浏览器有一个专门的功能——*cookie*！Cookies】不仅仅是为了凭证。他们可以在每个请求中存储你想让用户发给你的任何东西。

虽然这种幼稚的方法很有效，但通常你不希望在浏览器中以明文形式存储用户密码等敏感信息。相反，会话cookie通常携带一个随机字符串，在用户登录后立即生成。web服务器将随机字符串存储在用户昵称下的临时数据库中。如果浏览器以某种方式发布了会话cookie，则不会泄露任何有关用户密码的信息(尽管它可以用来模拟用户)。web服务器也有可能通过删除他们这边的cookie来终止会话，这很好。

![](img/03_001_UN01.png)

这种方法没有错，但在某些情况下，它可能无法很好地扩展。如果您有许多服务器，让所有服务器共享您的用户和随机字符串之间的关联可能会很烦人。相反，你可以在浏览器端存储更多的信息。让我们看看我们如何能做到这一点。

天真地，你可以让cookie包含用户名而不是随机字符串，但这显然是一个问题，因为我现在可以通过手动修改cookie中包含的用户名来模拟任何用户。也许你在第二章学到的散列函数可以帮助我们。花几分钟时间想一想散列函数可以防止用户篡改他们自己的cookies的方法。

第二种简单的方法是不仅存储用户名，还在cookie中存储用户名的摘要。您可以使用SHA-3这样的散列函数来散列用户名。我在图3.1中说明了这一点。你觉得这能行吗？

![](img/03_01.png)

图3.1为了验证对浏览器的请求，web服务器要求浏览器存储用户名和该用户名的散列，并在每个后续请求中发送该信息。

这种方法有一个大问题。请记住，哈希函数是一种公共算法，恶意用户可以对新数据进行重新计算。如果您不信任哈希的来源，它就不能提供数据完整性！事实上，图3.2显示，如果恶意用户修改了cookie中的用户名，他们也可以简单地重新计算cookie的摘要部分。

![](img/03_02.png)

图3.2恶意用户可以修改其cookies中包含的信息。如果cookie包含用户名和散列，则可以修改这两者来模拟不同的用户。

尽管如此，使用散列并不是一个愚蠢的想法。我们还能做什么？事实证明，有一个类似于哈希函数的原语，MAC，将完全满足我们的需要。

MAC 是一种秘密密钥算法，它接受输入，就像哈希函数一样，但它也接受秘密密钥(谁预见到了？)然后它产生一个名为*认证标签*的独特输出。这个过程是确定性的；给定相同的密钥和相同的消息，MAC产生相同的认证标签。我在图3.3中说明了这一点。

![](img/03_03.png)

图3.3消息认证码(MAC)界面。该算法采用密钥和消息，并确定性地产生唯一的认证标签。没有密钥，应该不可能复制该认证标签。

为了确保用户不能篡改他们的cookie，现在让我们利用这个新的原语。当用户第一次登录时，您用您的密钥和他们的用户名生成一个认证标签，并让他们将用户名和认证标签存储在一个 *cookie* 中。因为他们不知道密钥，所以他们无法为不同的用户名伪造有效的身份验证标记。

要验证他们的cookie，您需要做同样的事情:根据您的密钥和cookie中包含的用户名生成一个身份验证标记，并检查它是否与cookie中包含的身份验证标记匹配。如果匹配，它一定是来自您，因为您是唯一能够产生有效认证标签的人(在您的秘密密钥下)。我在图3.4中说明了这一点。

![](img/03_04.png)

图3.4恶意用户篡改了他的cookie，但无法为新的cookie伪造有效的认证标签。随后，网页无法验证cookie的真实性和完整性，因此丢弃该请求。

MAC就像一个私有的哈希函数，只有你能计算，因为你知道密钥。在某种意义上，你可以用一个键来个性化一个散列函数。与散列函数的关系不止于此。你将在本章后面看到，MAC通常是由散列函数构成的。接下来，让我们看一个使用真实代码的不同示例。

## 3.2代码示例

迄今为止，你是唯一一个使用MAC的人。让我们增加参与者的数量，并以此为动力来编写一些代码，看看MAC在实践中是如何使用的。想象一下，你想和别人交流，你不在乎别人看你的信息。然而，您真正关心的是消息的完整性:它们不能被修改！一个解决办法是让你和你的通信者在MAC上使用同一个密钥来保护你们通信的完整性。

对于这个例子，我们将使用最流行的MAC函数之一——*基于散列的消息认证码*(HMAC)——和 Rust编程语言。HMAC是一种消息认证码，其核心使用散列函数。它与不同的哈希函数兼容，但通常与SHA-2结合使用。如下面的清单所示，发送方只是接受一个密钥和一条消息，并返回一个身份验证标记。

清单3.1在Rust中发送经过认证的消息

```
use sha2::Sha256;
use hmac::{Hmac, Mac, NewMac};

fn send_message(key: &[u8], message: &[u8]) -> Vec<u8> {
    let mut mac = Hmac::<Sha256>::new(key.into());          ❶

    mac.update(message);                                    ❷

    mac.finalize().into_bytes().to_vec()                    ❸
}
```

❶ 用一个秘密密钥和SHA-256散列函数实例化HMAC

❷ 为HMAC缓冲更多输入

❸ 返回认证标签

在另一边，过程是相似的。在收到消息和认证标记后，您的朋友可以用相同的密钥生成他们自己的标记，然后对它们进行比较。与加密类似，双方需要共享相同的密钥来实现加密。下面的清单显示了这是如何工作的。

清单3.2在Rust中接收经过认证的消息

```
use sha2::Sha256;
use hmac::{Hmac, Mac, NewMac};

fn receive_message(key: &[u8], message: &[u8],
  authentication_tag: &[u8]) -> bool {
    let mut mac = Hmac::<Sha256>::new(key);         ❶
    mac.update(message);                            ❷

    mac.verify(&authentication_tag).is_ok()
}
```

❶ 接收者需要从相同的密钥和消息中重新创建认证标签。

❷ 检查再现的认证标签是否与接收的认证标签匹配

注意，这个协议并不完美:它允许重放。如果一条消息及其身份验证标记在以后的某个时间点被重放，它们仍然是可信的，但是您无法检测到这是一条重新发送给您的旧消息。在本章的后面，我将告诉你一个解决方案。现在你知道了MAC可以用来做什么，我将在下一节谈论一些MAC的“陷阱”。

## 3.3 MAC的安全属性

MAC就像所有的密码原语一样，有其奇怪之处和缺陷。在继续之前，我将提供一些关于MAC提供什么安全属性以及如何正确使用它们的解释。你将学会(按此顺序)

*   MAC可以抵抗认证标签的伪造。

*   为了安全起见，认证标签需要具有最小长度。

*   如果未经验证，消息可以重放。

*   验证认证标签容易出现错误。

### 3.3.1伪造认证标签

MAC的一般安全目标是防止新消息上的*认证标签伪造*。这意味着在不知道密钥 *k* 的情况下，人们无法计算他们选择的消息 *m* 上的认证标签*t*=*MAC*(*k*， *m* )。这听起来很公平，对吧？如果我们缺少一个参数，我们就不能计算一个函数。

然而，苹果电脑提供的保证远不止这些。现实世界中的应用程序经常让攻击者在一些受约束的消息上获得身份验证标记。例如，在我们的简介场景中就是这种情况，用户可以通过注册一个可用的昵称来获得几乎任意的身份验证标记。因此，即使面对这些更强大的攻击者，MAC也必须是安全的。MAC通常带有一个证明，即即使攻击者可以要求您为大量任意消息生成认证标签，攻击者仍然不能自己在从未见过的消息上伪造认证标签。

人们可能想知道证明这样一个极端性质有什么用。如果攻击者可以直接请求任意消息上的身份验证标记，那么还剩下什么需要保护呢？但这就是密码学中安全证明的工作方式:他们找到最强大的攻击者，并表明即使这样，攻击者也是无可救药的。在实践中，攻击者通常没有那么强大，因此，我们有信心，如果一个强大的攻击者不能做坏事，那么一个不太强大的攻击者就更没有追索权。

因此，只要MAC使用的密钥保密，你就应该被保护免受这种伪造*。这意味着密钥必须足够随机(更多信息在第8章)和足够大(通常是16字节)。此外，MAC容易受到我们在第二章中看到的同样类型的模糊攻击。如果您试图认证结构，请确保在用MAC认证它们之前序列化它们；否则，伪造可能是微不足道的。*

### 3.3.2认证标签的长度

另一种针对MAC使用的可能攻击是*碰撞*。请记住，查找哈希函数的冲突意味着查找两个不同的输入 *X* 和 *Y* ，使得*哈希* ( *X* ) = *哈希* ( *Y* )。我们可以通过定义当 *MAC* ( *k* ，*X*)=*MAC*(*k*， *Y* )为输入 *X* 和 *Y* 时的冲突来将这个定义扩展到MAC。

正如我们在第2章中所学的生日界限，如果我们的算法的输出长度很小，那么冲突很有可能被发现。例如，对于MAC，能够访问生成64位身份验证标签的服务的攻击者可以通过请求数量少得多(232)的标签，以很高的概率发现冲突。这种碰撞在实践中很少被利用，但是存在一些碰撞阻力很重要的情况。出于这个原因，我们需要一个能够限制这种攻击的认证标签大小。通常，使用128位认证标签，因为它们提供了足够的抵抗力。

*【请求2 <sup class="fm-superscript">64</sup> 认证标签】在连续1Gbps的链路中需要250，000年，并且在此期间不改变密钥K*。

—RFC 2104(“HMAC:用于消息认证的键控散列法”，1997年)

使用128位认证标签可能看起来违反直觉，因为我们想要散列函数的256位输出。但是哈希函数是公共算法，人们可以离线计算*，这使得攻击者能够大量优化和并行化攻击。使用像MAC这样的键控功能，攻击者无法有效地离线优化攻击，被迫直接向您请求身份验证标签，这通常会使攻击速度慢得多。128位认证标签需要来自攻击者的2次 <sup class="fm-superscript">64次</sup>T5次在线查询，以便有50%的机会发现冲突，这被认为是足够大的。尽管如此，人们可能仍然希望将身份验证标记增加到256位，这也是可能的。*

 *### 3.3.3重放攻击

有一点我还没提到的是*重播攻击*。让我们看一个容易受到这种攻击的场景。假设Alice和Bob使用不安全的连接在户外进行通信。为了保护消息不被篡改，他们给每条消息附加一个认证标签。更具体地说，它们都使用两个不同的密钥来保护连接的不同方面(按照最佳实践)。我在图3.5中说明了这一点。

![](img/03_05.png)

图3.5共享两个密钥`k1`和`k2`的两个用户交换带有认证标签的消息。这些标签是根据消息的方向从`k1`或`k2`计算出来的。一个恶意的观察者向用户重播其中一条消息。

在这种情况下，没有什么可以阻止恶意观察者向其接收者重播其中一条消息。依赖于MAC的协议必须意识到这一点，并针对这一点建立保护。一种方法是在MAC的输入端增加一个递增计数器，如图3.6所示。

![](img/03_06.png)

图3.6共享两个密钥`k1`和`k2`的两个用户交换带有认证标签的消息。这些标签是根据消息的方向从`k1`或`k2`计算出来的。一个恶意的观察者向用户重播其中一条消息。因为受害者已经增加了他的计数器，标签将在`2,`T5上被计算，并且将不会与攻击者发送的标签相匹配。这允许受害者成功拒绝重放的消息。

在实践中，计数器通常是固定的64位长度。这允许一个人在填满计数器之前发送2条 <sup class="fm-superscript">64条</sup>消息(冒着它绕回并重复自己的风险)。当然，如果共享秘密被频繁地轮换(意味着在 *X* 消息之后，参与者同意使用新的共享秘密)，那么在一次密钥轮换之后，计数器的大小可以被减小并重置为0。(你应该说服自己，用两个不同的键重用同一个计数器是可以的。)同样，由于不明确的攻击，计数器*从不变长*。

运动

你能找出可变长度计数器是如何让攻击者伪造认证标签的吗？

### 3.3.4恒定时间验证认证标签

最后一个问题对我来说很重要，因为我在审计的应用程序中多次发现这个漏洞。验证认证标签时，收到的认证标签和您计算的认证标签之间的比较必须在*恒定时间*内完成。这意味着比较应该总是花费相同的时间，假设接收到的是正确的大小。如果比较两个身份验证标签所花费的时间不是常数，可能是因为它返回了两个标签不同的时刻。这通常提供了足够的信息来启动攻击，攻击可以通过测量完成验证需要多长时间来逐字节地重新创建有效的认证标签。我在下面的漫画中解释了这一点。我们将这些类型的攻击称为*定时攻击*。

对我们来说幸运的是，实现MAC的密码库也提供了方便的函数来在恒定时间内验证认证标签。如果您想知道这是如何实现的，清单3.3展示了Golang如何在常量时间代码中实现认证标签比较。

![](img/03_06_UN02.png)

清单3.3 Golang中的常数时间比较

```
for i := 0; i < len(x); i++ {
    v |= x[i] ^ y[i]
}
```

诀窍在于永远不要拿走树枝。这究竟是如何工作的，留给读者去练习。

## 现实世界中的3.4 MAC

既然我已经介绍了什么是MAC，它们提供了哪些安全属性，那么我们就来看看人们在真实设置中是如何使用它们的。以下部分将解决这个问题。

### 3.4.1消息认证

MAC用在很多地方是为了保证两台机器或者两个用户之间的通信不被篡改。这在明文通信和加密通信两种情况下都是必要的。我已经解释了当通信以明文传输时这是如何发生的，在第四章中，我将解释当通信被加密时这是如何做到的。

### 3.4.2导出密钥

MAC的一个特殊性是，它们通常被设计成产生看起来随机的字节(像散列函数)。您可以使用此属性实现单个密钥来生成随机数或生成更多密钥。在关于秘密和随机性的第八章中，我将介绍基于HMAC的密钥派生函数(HKDF ),它通过使用HMAC(我们将在本章中讨论的MAC算法之一)来实现。

伪随机函数(PRF)

想象所有函数的集合，这些函数接受可变长度的输入并产生固定大小的随机输出。如果我们可以从这个集合中随机选择一个函数，并将其用作MAC(没有密钥)，那将会非常棒。我们只需要就哪个功能达成一致(有点像就一个键达成一致)。不幸的是，我们不能有这样一个集合，因为它太大了，但我们可以通过设计足够接近的东西来模拟选择这样一个随机函数:我们称这样的构造为*伪随机函数(PRFs)* 。HMAC和大多数实用的苹果电脑都是这种构造。相反，它们被一个关键参数随机化。选择不同的键就像选择一个随机函数。

运动

注意:并非所有MAC都是PRF。你能看出为什么吗？

### 3.4.3饼干的完整性

要跟踪用户的浏览器会话，您可以向他们发送一个随机字符串(与他们的元数据相关联)或直接向他们发送元数据，附带一个身份验证标签，这样他们就不能修改它。这是我在介绍例子中解释的。

### 3.4.4哈希表

编程语言通常公开被称为*哈希表*(也称为哈希映射、字典、关联数组等等)的数据结构，这些数据结构使用非加密哈希函数。如果一个服务以一种非加密哈希函数的输入可以被攻击者控制的方式公开这个数据结构，这可能导致*拒绝服务* (DoS) *攻击*，这意味着攻击者可以使服务不可用。为了避免这种情况，非加密散列函数通常在程序开始时被随机化。

许多主要应用程序使用带有随机密钥的MAC来代替非加密哈希函数。许多编程语言(如Rust、Python和Ruby)或主要应用程序(如Linux内核)都是如此。他们都使用了 *SipHash* ，这是一个名不副实的MAC，针对短认证标签进行了优化，在程序开始时会生成一个随机密钥。

## 3.5消息认证码(MAC)在实践中的应用

您了解到MAC是一种加密算法，可以在一方或多方之间使用，以保护信息的完整性和真实性。由于广泛使用的MAC也表现出良好的随机性，MAC也经常用于在不同类型的算法中确定性地产生随机数(例如，您将在第11章学习的基于时间的一次性密码[TOTP]算法)。在这一节中，我们将研究目前可以使用的两种标准化MAC算法——HMAC和KMAC。

### 3.5.1 HMAC，一种基于哈希的MAC

最广泛使用的MAC是HMAC(用于*基于散列的MAC* )，由M. Bellare、R. Canetti和h .科劳兹克于1996年发明，并在RFC 2104、FIPS出版物198和ANSI X9.71中指定。HMAC，正如其名称所示，是一种使用散列函数和密钥的方法。使用散列函数来构建MAC是一个流行的概念，因为散列函数具有广泛可用的实现，在软件中速度很快，并且还受益于大多数系统上的硬件支持。记得我在第2章提到过，由于*长度扩展攻击*，SHA-2不应该被直接用于散列秘密(在本章末尾会有更多关于那个)。人们如何知道如何将散列函数转换成键控函数？这就是HMAC为我们解决的问题。在引擎盖下，HMAC遵循这些步骤，我在图3.7中直观地说明了这些步骤:

1.  它首先从主键创建两个键:*k*1 =*k*⊕*ipad*和*k*2 =*k*⊕*opad*，其中 *ipad* (内部填充)和 *opad* (外部填充)为常量

2.  然后，它将密钥`k1`与消息连接起来，并对其进行哈希处理。

3.  结果与关键字`k2`连接，并再次散列。

4.  这产生了最终的认证标签。

![](img/03_07.png)

图3.7 HMAC的工作原理是对一个键的串联(`||`)、`k1`和输入消息进行哈希运算，然后对一个键的串联、`k2`和第一次运算的输出进行哈希运算。`k1`和`k2`都是确定性地从密钥`k`中导出的。

由于HMAC是可定制的，其认证标签的大小由所使用的散列函数决定。例如，HMAC-SHA256利用SHA-256并生成256位的身份验证标记，HMAC-SHA512生成512位的身份验证标记，等等。

警告 虽然我们可以截断HMAC的输出以减小其大小，但正如我们前面谈到的，认证标签至少应该是128位。这并不总是被遵守，并且由于显式地处理有限数量的查询，一些应用程序将低至64位。这种方法也有利弊，再次强调，在做一些不标准的事情之前阅读细则是很重要的。

为了便于证明，HMAC是这样建造的。在几篇论文中，HMAC被证明是安全的，只要下面的哈希函数具有一些好的特性，所有密码安全哈希函数都应该具有这些特性。因此，我们可以将HMAC与大量哈希函数结合使用。今天，HMAC主要和SHA-2一起使用。

### 3.5.2 KMAC，基于cSHAKE的MAC

由于SHA-3不容易受到长度扩展攻击(这实际上是SHA-3竞赛的一个要求)，因此将SHA-3与HMAC一起使用而不是像`SHA-3-256(key` `||` `message)`这样在实践中工作良好的东西几乎没有意义。这正是KMAC所做的。

KMAC使用了cSHAKE，这是你在第二章看到的可扩展输出功能(XOF)的定制版本。KMAC明确地编码MAC密钥、输入和请求的输出长度(KMAC是某种可扩展的输出MAC ),并将其作为输入提供给cSHAKE进行吸收(见图3.8)。KMAC还使用“KMAC”作为函数名(来定制cSHAKE ),此外，还可以使用用户定义的定制字符串。

![](img/03_08.png)

图3.8 KMAC只是切克的一个包装。为了使用密钥，它(以明确的方式)将密钥、输入和输出长度编码为cSHAKE的输入。

有趣的是，因为KMAC也吸收了请求的输出长度，几个不同输出长度的调用提供了完全不同的结果，这在一般的XOFs中很少出现。这使得KMAC在实践中具有相当多的功能。

## 3.6 SHA-2和长度扩展攻击

我们已经多次提到，不应该与SHA-2散列秘密，因为它不能抵抗*长度扩展攻击*。在本节中，我们旨在对此攻击提供一个简单的解释。

让我们回到我们的介绍场景，回到我们尝试简单地使用SHA-2来保护cookie的完整性的那一步。请记住，这还不够好，因为用户可以篡改cookie(例如，通过添加一个`admin=true`字段)并在cookie上重新计算散列。事实上，SHA-2是一个公共函数，没有什么可以阻止用户这样做。图3.9说明了这一点。

![](img/03_09.png)

图3.9网页向用户发送一个cookie，后跟该cookie的散列。然后，要求用户在每个后续请求中发送cookie来验证自己。不幸的是，恶意用户可以篡改cookie并重新计算散列，破坏完整性检查。该cookie随后被网页接受为有效。

下一个最好的主意是在我们散列的内容中添加一个密钥。这样，用户无法重新计算摘要，因为需要密钥，这与MAC非常相似。收到被篡改的cookie后，页面计算`SHA-256(key` `||` `tampered_cookie)`，其中`||`表示两个值的连接，并获得与恶意用户可能发送的内容不匹配的内容。图3.10说明了这种方法。

![](img/03_10.png)

图3.10通过在计算cookie的散列值时使用一个密钥，人们可能会认为想要篡改他们自己的cookie的恶意用户将无法通过新的cookie计算出正确的摘要。我们稍后会看到，SHA-256的情况并非如此。

不幸的是，SHA-2有一个令人讨厌的特性:从一个输入的摘要中，我们可以计算出一个输入的摘要等等。这是什么意思？让我们看一下图3.11，其中一个用SHA-256作为`SHA-256(secret` `||` `input1)`。

![](img/03_11.png)

图3.11 SHA-256散列一个与cookie连接的秘密(这里命名为`input1`)。请记住，SHA-256的工作方式是使用Merkle–damg rd结构，从初始化向量(IV)开始，对输入块迭代调用压缩函数。

图3.11是高度简化的，但是假设`input1`是字符串`user=bob`。请注意，此时获得的摘要实际上是哈希函数的完整中间状态。没有什么可以阻止人们假装`padding`部分是输入的部分，继续Merkle-damg rd舞蹈。在图3.12中，我们说明了这种攻击，其中一个人将获取摘要并计算`input1` `||` `padding` `||` `input2`的散列。在我们的例子中，`input2`就是`&admin=true`。

![](img/03_12.png)

图3.12 cookie的SHA-256哈希(中间摘要)的输出用于将哈希扩展到更多数据，创建与`input1`、第一个填充字节和`input2`连接的秘密哈希(正确摘要)。

此漏洞允许用户从给定的摘要继续散列，就像操作没有完成一样。这打破了我们以前的协议，如图3.13所示。

![](img/03_13.png)

图3.13攻击者成功利用长度扩展攻击篡改他们的cookie，并使用之前的哈希计算出正确的哈希。

第一个填充现在需要成为输入的一部分，这一事实可能会阻止某些协议被利用。尽管如此，最小的变化也可能重新引入漏洞。由于这个原因，一个人不应该和SHA-2分享秘密。当然，还有其他几种正确的做法(比如`SHA-256(k` `||` `message` `||` `k)`作品)，这就是HMAC提供的。因此，如果您想使用SHA-2，请使用HMAC；如果您喜欢SHA-3，请使用KMAC。

## 总结

*   消息认证码(MAC)是对称加密算法，允许共享同一密钥的一方或多方验证消息的完整性和真实性。

    *   为了验证消息及其相关认证标签的真实性，可以重新计算消息的认证标签和密钥，然后匹配这两个认证标签。如果它们不同，则消息已被篡改。
    *   总是在恒定时间内将接收到的认证标签与计算出的认证标签进行比较。
*   虽然MAC在默认情况下保护消息的完整性，但它们不会检测消息何时被重放。

*   标准化且广为接受的MAC是HMAC和KMAC标准。

*   人们可以将HMAC与不同的散列函数一起使用。实际上，HMAC经常与SHA-2散列函数一起使用。

*   认证标签的最小长度应为128位，以防止认证标签的冲突和伪造。

*   不要直接使用SHA-256来构建MAC，因为这样做可能会出错。总是使用像HMAC这样的函数来做这件事。*